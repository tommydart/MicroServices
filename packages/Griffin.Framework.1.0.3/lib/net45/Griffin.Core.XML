<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Griffin.Core</name>
    </assembly>
    <members>
        <member name="T:Griffin.ApplicationServices.IGuardedService">
            <summary>
            Guarded services can be stopped/started/restarted by this library
            </summary>
        </member>
        <member name="P:Griffin.ApplicationServices.IGuardedService.IsRunning">
            <summary>
            Returns if the service is currently running
            </summary>
        </member>
        <member name="T:Griffin.ApplicationServices.IApplicationService">
            <summary>
            A service (class) which is running during the entire application lifetime
            </summary>
            <remarks>
            <para>
            Services are intended to be started when the application is started and stopped when the application is stopped.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.ApplicationServices.IApplicationService.Start">
            <summary>
            Start service
            </summary>
        </member>
        <member name="M:Griffin.ApplicationServices.IApplicationService.Stop">
            <summary>
            stop service
            </summary>
        </member>
        <member name="T:Griffin.ConstructorExtensions">
            <summary>
                Credits http://rogeralsing.com/2008/02/28/linq-expressions-creating-objects/
            </summary>
        </member>
        <member name="M:Griffin.ConstructorExtensions.CreateFactory(System.Reflection.ConstructorInfo)">
            <summary>
                Creates a delegate which allocates a new object faster than  <see cref="M:System.Activator.CreateInstance``1"/>.
            </summary>
            <param name="ctor">The ctor.</param>
            <returns>The activator</returns>
            <remarks>
                The method uses an expression tree to build
                a delegate for the specified constructor
            </remarks>
        </member>
        <member name="T:Griffin.Container.NamespaceDoc">
            <summary>
            Interfaces defining what an inversion of control container should expose.
            </summary>
        </member>
        <member name="T:Griffin.Container.ServiceNotRegisteredException">
            <summary>
                The requested service has not been registerd.
            </summary>
        </member>
        <member name="P:Griffin.Container.ServiceNotRegisteredException.ServiceType">
            <summary>
                Gets services that was requested
            </summary>
        </member>
        <member name="T:Griffin.Container.DependencyMissingException">
            <summary>
            A dependency was missing when we tried to resolve a service.
            </summary>
            <remarks>
            <para>
            Thrown when the requested service can be found, but one of the dependencies that the implementation of the service has is missing.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Container.DependencyMissingException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Container.DependencyMissingException"/> class.
            </summary>
            <param name="message">The message.</param>
            <param name="inner">The inner.</param>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="T:Griffin.Container.IContainer">
            <summary>
                Contract for an inversion of control container
            </summary>
        </member>
        <member name="M:Griffin.Container.IContainer.Resolve``1">
            <summary>
                Resolve a service
            </summary>
            <typeparam name="TService">Service that we want to get an implementation for</typeparam>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.Resolve(System.Type)">
            <summary>
                Resolve a service
            </summary>
            <param name="service">Service that we want to get an implementation for.</param>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.ResolveAll``1">
            <summary>
                Resolve a service
            </summary>
            <typeparam name="TService">Service that we want to get an implementation(s) for</typeparam>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.ResolveAll(System.Type)">
            <summary>
                Resolve a service
            </summary>
            <param name="service">Service that we want to get an implementation(s) for</param>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainer.CreateScope">
            <summary>
                Created a child scope (i.e. a container with a lifetime that you control. Dispose the scope to clean up all
                resolved services).
            </summary>
            <returns>A child container (i.e. a lifetime scope)</returns>
        </member>
        <member name="T:Griffin.Container.IContainerScope">
            <summary>
            Represents a container with a limited lifetime.
            </summary>
            <remarks>
            <para>
            A child container stores all scoped objects in a list and will dispose all resolved objects when the scope is being disposed.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Container.IContainerScope.Resolve``1">
            <summary>
                Resolve a service
            </summary>
            <typeparam name="TService">Service that we want to get an implementation for</typeparam>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainerScope.Resolve(System.Type)">
            <summary>
                Resolve a service
            </summary>
            <param name="service">Service that we want to get an implementation for.</param>
            <returns>object that implements the specified service</returns>
            <exception cref="T:Griffin.Container.ServiceNotRegisteredException">Failed to find an implementation for the service</exception>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainerScope.ResolveAll``1">
            <summary>
                Resolve a service
            </summary>
            <typeparam name="TService">Service that we want to get an implementation(s) for</typeparam>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="M:Griffin.Container.IContainerScope.ResolveAll(System.Type)">
            <summary>
                Resolve a service
            </summary>
            <param name="service">Service that we want to get an implementation(s) for</param>
            <returns>A list of implementations, or an empty list if no implementations are found.</returns>
            <exception cref="T:Griffin.Container.DependencyMissingException">A dependency was missing when constructing the service implementation.</exception>
        </member>
        <member name="T:Griffin.Data.AdoNetUnitOfWork">
            <summary>
                An unit of work implementation which uses the interfaces that is defined in ADO.NET and should therefore work with
                most ADO.NET driver implementations.
            </summary>
            <example>
                <code>
            public IUnitOfWork Create()
            {
                var conString = ConfigurationManager.ConnectionStrings("MyDb").ConnectionString;
                var con = new SqlConnection(conString);
                con.Open();
                return new AdoNetUnitOfWork(con, true);
            }
            
            UnitOfWorkFactory.SetFactoryMethod(() => Create());
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.IAdoNetUnitOfWork">
            <summary>
                ADO.NET features for a Unit Of Work
            </summary>
        </member>
        <member name="T:Griffin.Data.IUnitOfWork">
            <summary>
            Unit of work contract
            </summary>
            <remarks>
            <para>
            Disposing without <c>SaveChanges()</c> being called means that the transaction should be aborted.
            </para>
            </remarks>
            <example>
            <code>
            using (var uow = UnitOfWorkFactory.Create())
            {
                var repos = new UserRepository(uow);
                repos.Create(user);
            
                uow.SaveChanges();
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.IUnitOfWork.SaveChanges">
            <summary>
            Commit changes.
            </summary>
            <exception cref="T:Griffin.Data.TransactionAlreadyClosedException">UoW have already been saved.</exception>
        </member>
        <member name="M:Griffin.Data.IAdoNetUnitOfWork.CreateCommand">
            <summary>
                Create a new command
            </summary>
            <returns>Created command (never <c>null</c>)</returns>
            <remarks>
                <para>The created command have been enlisted in the local transaction which is wrapped by this Unit Of Work.</para>
            </remarks>
            <exception cref="T:System.Data.DataException">Failed to create the command</exception>
        </member>
        <member name="M:Griffin.Data.IAdoNetUnitOfWork.Execute(System.String,System.Object)">
            <summary>
            Execute a SQL query within the transaction
            </summary>
            <param name="sql"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.#ctor(System.Data.IDbConnection)">
            <summary>
            </summary>
            <param name="connection">
                A connection may not be shared between multiple transactions, so make sure that the connection
                is unique for this uow
            </param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.#ctor(System.Data.IDbConnection,System.Boolean)">
            <summary>
            </summary>
            <param name="connection">
                A connection may not be shared between multiple transactions, so make sure that the connection
                is unique for this uow
            </param>
            <param name="ownsConnection">This unit of work owns the connection and will close it when being disposed.</param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.#ctor(System.Data.IDbConnection,System.Boolean,System.Data.IsolationLevel)">
            <summary>
            </summary>
            <param name="connection">
                A connection may not be shared between multiple transactions, so make sure that the connection
                is unique for this uow
            </param>
            <param name="ownsConnection">This unit of work owns the connection and will close it when being disposed.</param>
            <param name="isolationLevel">Isolation level that the transaction should use.</param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.SaveChanges">
            <summary>
                Commit changes.
            </summary>
            <exception cref="T:Griffin.Data.TransactionAlreadyClosedException">Transaction have already been commited or disposed.</exception>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.CreateCommand">
            <summary>
                Create a new command
            </summary>
            <returns>Created command (never <c>null</c>)</returns>
            <remarks>
                <para>The created command have been enlisted in the local transaction which is wrapped by this Unit Of Work.</para>
            </remarks>
            <exception cref="T:System.Data.DataException">Failed to create the command</exception>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.Execute(System.String,System.Object)">
            <summary>
            Execute a SQL query within the transaction
            </summary>
            <param name="sql"></param>
            <param name="parameters"></param>
        </member>
        <member name="M:Griffin.Data.AdoNetUnitOfWork.Execute(System.String)">
            <summary>
            Execute a SQL query within the transaction
            </summary>
            <param name="sql"></param>
        </member>
        <member name="T:Griffin.Data.CommandExtensions">
            <summary>
            Extensions for IDbCommand
            </summary>
        </member>
        <member name="M:Griffin.Data.CommandExtensions.AddParameter(System.Data.IDbCommand,System.String,System.Object)">
            <summary>
                Add a parameter to a command
            </summary>
            <param name="command">Command to add parameter to</param>
            <param name="name">Name of the parameter</param>
            <param name="value">Value (will be changed to <c>DBNull.Value</c> automatically if it's <c>null</c>).</param>
            <returns>Created parameter</returns>
            <example>
                <code>
            using (var command = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT avg(Age) FROM Users WHERE LastName Like @name";
                cmd.AddParameter("name", "F%");
                return (int)cmd.ExecuteScalar();
            }
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.EntityNotFoundException">
            <summary>
                Thrown when a method which expects to find an entity doesn't.
            </summary>
            <remarks>
            <para>this error message will always include information to be able to identify the missing entity.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.EntityNotFoundException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown. </param><param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param><exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic). </exception><filterpriority>2</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/><IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/></PermissionSet>
        </member>
        <member name="P:Griffin.Data.EntityNotFoundException.Message">
            <summary>
                Gets a message that describes the current exception.
            </summary>
            <returns>
                The error message that explains the reason for the exception, or an empty string("").
            </returns>
        </member>
        <member name="P:Griffin.Data.EntityNotFoundException.CommandText">
            <summary>
            Gets command that was executed
            </summary>
        </member>
        <member name="P:Griffin.Data.EntityNotFoundException.CommandParameters">
            <summary>
            The command parameter collection joined as a string
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.AdoNetEntityEnumerable`1">
            <summary>
            Wrapper around the <see cref="T:Griffin.Data.Mapper.AdoNetEntityEnumerator`1"/> which does the actual work.
            </summary>
            <typeparam name="TEntity">Type of entity to convert the rows to</typeparam>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerable`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">May only traverse AdoNetEntityEnumerable once</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerable`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Griffin.Data.Mapper.AdoNetEntityEnumerator`1">
            <summary>
                Traverses a recordset returned from a <c>IDbCommand</c> and converts each row to an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to convert to.</typeparam>
            <remarks>
                <para>
                    Will not do any conversions until the <see cref="P:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Current"/> property is being called. Hence you can call the
                    <see cref="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.MoveNext"/>
                    method any amount of times that you need without the mapping being used.
                </para>
                <para></para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Dispose">
            <summary>
                Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.MoveNext">
            <summary>
                Advances the enumerator to the next element of the collection.
            </summary>
            <returns>
                true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of
                the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Reset">
            <summary>
                Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception>
        </member>
        <member name="P:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.Current">
            <summary>
                Gets the element in the collection at the current position of the enumerator.
            </summary>
            <returns>
                The element in the collection at the current position of the enumerator.
            </returns>
        </member>
        <member name="P:Griffin.Data.Mapper.AdoNetEntityEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>
                Gets the current element in the collection.
            </summary>
            <returns>
                The current element in the collection.
            </returns>
        </member>
        <member name="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider">
            <summary>
                Scans all assemblies in the current <c>AppDomain</c> after types that implement <see cref="T:Griffin.Data.Mapper.IEntityMapper"/>.
            </summary>
            <remarks>
                <para>
                    All mappers are added as created instances to an internal cache for fast access during mapping operations. Hence it's important
            that they are thread safe and considered as singletons when this class is used.
                </para>
            <para>
            
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.IMappingProvider">
            <summary>
            Used by the <see cref="!:MappingProvider"/>
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Get``1">
            <summary>
                Retrieve a mapper.
            </summary>
            <typeparam name="TEntity">Type of entity to retrieve a mapper for.</typeparam>
            <returns>Mapper</returns>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Failed to find a mapping for the given entity type.</exception>
            <remarks>
            <para>
            Do note that the mapper must implement <see cref="T:Griffin.Data.Mapper.IEntityMapper`1"/> interface for this method to work.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Get(System.Type)">
            <summary>
                Retrieve a mapper.
            </summary>
            <typeparam name="T">Type of entity to retrieve a mapper for.</typeparam>
            <param name="entityType">Type of entity to get a mapper for</param>
            <returns>Mapper</returns>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Failed to find a mapping for the given entity type.</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Scan">
            <summary>
                Scan all loaded assemblies in the current domain.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AssemblyScanningMappingProvider.Scan(System.Reflection.Assembly)">
            <summary>
                Scan all loaded assemblies in the current domain.
            </summary>
            <param name="assembly">Assembly to scan for types that implement <see cref="T:Griffin.Data.Mapper.IEntityMapper"/>.,</param>
        </member>
        <member name="P:Griffin.Data.Mapper.AssemblyScanningMappingProvider.IgnoreInvalidMappers">
            <summary>
            Ignore mapper classes which are invalid when locating all mappings in the loaded assemblies.
            </summary>
            <remarks>
            <para>The <c>Scan()</c> method </para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.AssemblyScanningMappingProvider.ReplaceDuplicateMappers">
            <summary>
            If <c>true</c>, we'll replace the first mapper if we encounter a second mapper for the same entity.
            </summary>
            <remarks>
            <para>
            <c>false</c> means that an exception will be thrown
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.AsyncCommandExtensions">
            <summary>
                Asynchronous extensions for <see cref="T:System.Data.Common.DbCommand"/>.
            </summary>
            <remarks>
            <para>
            All methods which do not take a mapper class uses the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to identify the mapper to use when converting to/from rows in the database. SQL commands
            for CRUD operations are provided by a <see cref="T:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder"/> implementation (specific for each database engine).
            </para>
            <para>
            CRUD operations are typically performed on the <see cref="T:Griffin.Data.IAdoNetUnitOfWork"/> or <see cref="T:System.Data.IDbConnection"/> instead as you do not have to create your own command then.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstAsync``1(System.Data.Common.DbCommand)">
            <summary>
                Fetches the first found entity asynchronously
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>
                entity
            </returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find specified entity.</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstAsync<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstAsync``1(System.Data.Common.DbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Fetches the first found entity asynchronously
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="mapper"></param>
            <returns>
                entity
            </returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstAsync<User>(new MyCustomMapper());
                }
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Griffin.Data.Mapper.EntityMapper`1"/>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstOrDefaultAsync``1(System.Data.Common.DbCommand)">
            <summary>
                Fetches the first row if found.
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct mapper.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstOrDefaultAsync<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.FirstOrDefaultAsync``1(System.Data.Common.DbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Fetches the first row if found.
            </summary>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="mapper">Mapper used to convert rows to entities</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return await cmd.FirstOrDefaultAsync<User>(new MyCustomMapping());
                }
            }
            ]]>
            </code>
            </example>
            <seealso cref="T:Griffin.Data.Mapper.EntityMapper`1"/>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToEnumerableAsync``1(System.Data.Common.DbCommand)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The command is executed asynchronously.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    As the returned item is a custom lazy loaded enumerable it's quite fast as nothing is mapped if you do like:
                </para>
                <example>
                    <code>
            <![CDATA[
            using (var cmd = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT * FROM Users";
                var users = await cmd.ToEnumerable<User>();
                return users.Skip(1000).Take(50).ToList();
            }
            ]]>
            </code>
                </example>
                <para>
                    Do note that it will still read all rows and is therefore slower than paging in the SQL server. It will however
                    use a lot less
                    allocations than building a complete list first.
                </para>
                <para>
                    If the result returnd from the query is all records that you want it's probably more effecient to use
                    <see cref="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToListAsync``1(System.Data.Common.DbCommand)"/>.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct mapper.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToEnumerableAsync``1(System.Data.Common.DbCommand,System.Boolean)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The command is executed asynchronously.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct mapper.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToEnumerableAsync``1(System.Data.Common.DbCommand,System.Boolean,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapper">Mapper used to convert rows to entities</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The command is executed asynchronously.
                </para>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToListAsync``1(System.Data.Common.DbCommand)">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    Uses the <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct mapper.
                </para>
                <para>
                    Make sure that you <c>await</c> the method, as nothing the reader is not disposed directly if you don't.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncCommandExtensions.ToListAsync``1(System.Data.Common.DbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to map</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="mapper">Mapper to use when converting rows to entities</param>
            <returns>A list which is generated asynchronously.</returns>
            <remarks>
                <para>
                    Make sure that you <c>await</c> the method, as nothing the reader is not disposed directly if you don't.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.AsyncConnectionExtensions">
            <summary>
            Asynchronous extensions for database connections
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.FirstOrDefaultAsync``1(System.Data.IDbConnection,System.Object)">
            <summary>
                Fetches the first row if found.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="constraints">Command to invoke <c>ExecuteReaderAsync()</c> on.</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>
                Entity if found; otherwise <c>null</c>.
            </returns>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
                <para>Uses <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/> to find the correct mapper.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstOrDefaultAsync<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return await _connection.FirstOrDefaultAsync<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.FirstAsync``1(System.Data.IDbConnection,System.Object)">
            <summary>
            Get an object.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">connection to load entity from</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Found entity</returns>
            <example>
                <code>
            <![CDATA[
            public async Task<User> GetUser(int userId)
            {
                return await _connection.FirstAsync<User>(new { Id = userId });
            }
            ]]>
            </code>
            <para>
            You can also use % for LIKE searches:
            </para>
                <code>
            <![CDATA[
            return await _connection.FirstAsync<User>(new { FirstName = 'Jon%', LastName = 'Gau%' });
            ]]>
            </code>
            <para>
            Which will translate into "WHERE FirstName LIKE 'Jon%' AND LastName LIKE 'Gau%'"
            </para>
            </example>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find an entity mathing the query</exception>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.InsertAsync``1(System.Data.IDbConnection,``0)">
            <summary>
            Insert an entity into the database
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to use</param>
            <param name="entity">Entity to insert.</param>
            <returns>Task to wait on for completion</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.UpdateAsync``1(System.Data.IDbConnection,``0)">
            <summary>
            Update an existing entity
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to use</param>
            <param name="entity">Entity to update.</param>
            <returns>Task to wait on for completion</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.DeleteAsync``1(System.Data.IDbConnection,``0)">
            <summary>
            Delete an entity
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">DB connection.</param>
            <param name="entity">Entity to remove.</param>
            <returns>Task to wait on for completion.</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.DeleteAsync``1(System.Data.IDbConnection,System.Object)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">DB connection.</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Task to wait on for completion.</returns>
            <example>
            <code>
            <![CDATA[
            public async Task DeleteUser(int userId)
            {
                await connection.DeleteAsync(new { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncConnectionExtensions.ExecuteNonQueryAsync(System.Data.IDbConnection,System.String,System.Object)">
            <summary>
            Execute a query directly
            </summary>
            <param name="connection">Connection to execute query on</param>
            <param name="sql">sql query</param>
            <param name="parameters">parameters used in the query</param>
            <returns>Task to wait on for completion</returns>
            <remarks>
            <para>Do note that the query must be using table column names and not class properties. No mapping is being made.</para>
            <para><c>null</c> is automatically replaced by <c>DBNull.Value</c> for the parameters</para>
            </remarks>
            <example>
            <code>
            public async Task Execute(IDbConnection connection)
            {
                connection.ExecuteNonQueryAsync("UPDATE Users SET Discount = Discount + 10 WHERE OrganizationId = @orgId", new { orgId = 10});
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions">
            <summary>
            Extension methods for our AdoNet unit of work.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.InsertAsync``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
            Insert a new row into the database.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="entity">entity to insert into the database.</param>
            <returns>Task to wait on for completion</returns>
            <remarks>
            <para>
            Will assign the PK value to the 
            </para>
            </remarks>
            <example>
            <code>
            var user = new User(10, "Jonas");
            using (var uow = UnitOfWorkFactory.Create())
            {
                await uow.InsertAsync(user);
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.DeleteAsync``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="entity">Uses the primary key column(s), as defined in the mapping, to remove the entry.</param>
            <returns>Task to wait on for completion.</returns>
            <example>
            <code>
            <![CDATA[
            public async Task DeleteUser(int userId)
            {
                return await _unitOfWork.DeleteAsync(new User { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.FirstAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
            Find first row in db.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="constraints">dynamic specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Task to wait on for completion.</returns>
            <example>
            <code>
            <![CDATA[
            public async Task Ban(int userId)
            {
                using (var uow = UnitOfWorkFactory.Create())
                {
                    var user = await uow.FirstAsync(new { Id = 1 });
                    user.State = AccountState.Banned;
                    await uow.UpdateAsync(user);
            
                    uow.SaveChanges();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.DeleteAsync``1(Griffin.Data.IAdoNetUnitOfWork,System.Object)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Unit of work to execute command in.</param>
            <param name="constraints">Constraints to be used. any field with '%' in the name will return in <c>LIKE</c> queries.</param>
            <returns>Task to wait on for completion.</returns>
            <example>
            <code>
            <![CDATA[
            public async Task DeleteUser(int userId)
            {
                await _unitOfWork.DeleteAsync(new { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.AsyncAdoNetUnitOfWorkExtensions.UpdateAsync``1(Griffin.Data.IAdoNetUnitOfWork,``0)">
            <summary>
            Update an entity
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="unitOfWork">Transaction wrapper</param>
            <param name="entity">Entity to update</param>
            <returns>Task to wait on for completion</returns>
            <example>
            <code>
            using (var uow = UnitOfWorkFactory.Create())
            {
                var user = await uow.FirstAsync(new { Id = 1 });
                user.State = AccountState.Banned;
                await uow.UpdateAsync(user);
            
                uow.SaveChanges();
            }
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilder">
            <summary>
            Base class for command builders
            </summary>
            <remarks>
            Creates SQL commands per the SQL92 standard. Inherit this class to customize different commands.
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder">
            <summary>
            Used to be able to adapt basic queries to the SQL dialetcs of each database engine.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.InsertCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute an INSERT INTO using the entity as data
            </summary>
            <param name="command">Command that will be executed after this method call.</param>
            <param name="entity">Entity specified; If possible, set the entity primary key value when done.</param>
            <remarks>
            <para>The command should not be executed in the imlementation of this interface. </para>
            <para>You may however execute commads </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.UpdateCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute an UPDATE using the entity as data
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <param name="entity">Update is made on all properties but those specified as primary key (which is used in the WHERE clause)</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.DeleteCommand(System.Data.IDbCommand,System.Object)">
            <summary>
            Modifies the command to execute a DELETE statement
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <param name="entity">Only primary key properties are used in the WHERE clause</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.TruncateCommand(System.Data.IDbCommand)">
            <summary>
            Truncate all rows in a table
            </summary>
            <param name="command">Command that will be executed after this method call</param>
            <remarks>
            <para>Some dialects have a special command which can be used to DELETE all rows from a table, everyone else should just use a DELETE statement without a WHERE clause.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.CommandBuilders.ICommandBuilder.ParameterPrefix">
            <summary>
            Gets prefix to use for data parameters (typically '@' or ':')
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.CommandBuilders.CommandBuilder.ParameterPrefix">
            <summary>
            Gets prefix to use for data parameters (typically '@' or ':')
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory">
            <summary>
            Used to produce factories of the correct 
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.NamespaceDoc">
            <summary>
            Command builders are used to create standard SQL commands like CRUD and basic SELECTs. They exist to be able to adapt the
            commands for every RDBMS out there.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder">
            <summary>
            Specializations for Sql Server.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandBuilders.SqlServerCommandBuilder.TruncateCommand(System.Data.IDbCommand)">
            <summary>
            Uses TRUNCATE TABLE
            </summary>
            <param name="command"></param>
        </member>
        <member name="T:Griffin.Data.Mapper.CommandExtensions">
            <summary>
                Extensions for <see cref="T:System.Data.IDbCommand"/>.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ApplyConstraints``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0},System.Object)">
            <summary>
            Takes an anonymous/dynamic objects and converts it into a WHERE clause using the supplied mapping.
            </summary>
            <typeparam name="TEntity">Type of entity to load, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to add parameters to (should end with " WHERE " so that this method can add the constraints properly)</param>
            <param name="mapper">Mapper to use to convert properties to columns</param>
            <param name="constraints">properties in an anonymous object</param>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.First``1(System.Data.IDbCommand)">
            <summary>
                Fetches the first row from a query, but mapped as an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>Entity</returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.First<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.First``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Fetches the first row from a query, but mapped as an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="mapper">Mapper which can convert the db row to an entity.</param>
            <returns>Entity</returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public void GetUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.First<User>(new MyCustomMapper());
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.FirstOrDefault``1(System.Data.IDbCommand)">
            <summary>
                Fetches the first row and maps it as an entity (if found).
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>Entity if found; otherwise <c>null</c>.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.FirstOrDefault<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.FirstOrDefault``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Fetches the first row and maps it as an entity (if found).
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="mapper">Mapper which can convert the db row to an entity.</param>
            <returns>Entity if found; otherwise <c>null</c>.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindUser(string id)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
                    return cmd.FirstOrDefault<User>(new MyCustomUserMapper());
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToEnumerable``1(System.Data.IDbCommand)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    Hence the different between this method and the <see cref="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)"/>
                    method is
                    that this one do not create a list in the memory with all entities. It's therefore perfect if you want to
                    process a large amount
                    of rows.
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public TimeSpan CalculateWorkHours()
            {
                int minutes = 0;
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
            
                    // can contain a large amount of rows without consuming memory
                    using (var incidents = cmd.ToEnumerable<Incident>())
                    {
                        foreach (var incident in incidents)
                        {
                            if (!incident.IsStarted)
                                continue;
            
                            var spentTime = incident.ReportedTime.Sum(x => x.TotalSpentTime);
                            minutes += spentTime;
                        }
                    }
                }
            
                return TimeSpan.FromMinutes(minutes);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToEnumerable``1(System.Data.IDbCommand,System.Boolean)">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    As the returned item is a custom lazy loaded enumerable it's quite fast as nothing is mapped if you do like:
                </para>
                <example>
                    <code>
            <![CDATA[
            using (var cmd = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT * FROM Users";
                var pagedUsers = cmd.ToEnumerable<User>().Skip(1000).Take(50).ToList();
            }
            ]]>
            </code>
                </example>
                <para>
                    Do note that it will still read all rows and is therefore slower than paging in the SQL server. It will however
                    use a lot less
                    allocations than building a complete list first.
                </para>
                <para>
                    If the result returnd from the query is all records that you want it's probably more effecient to use
                    <see cref="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)"/>.
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public TimeSpan CalculateWorkHours()
            {
                int minutes = 0;
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
            
                    // can contain a large amount of rows without consuming memory
                    using (var incidents = cmd.ToEnumerable<Incident>())
                    {
                        foreach (var incident in incidents)
                        {
                            if (!incident.IsStarted)
                                continue;
            
                            var spentTime = incident.ReportedTime.Sum(x => x.TotalSpentTime);
                            minutes += spentTime;
                        }
                    }
                }
            
                return TimeSpan.FromMinutes(minutes);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToEnumerable``1(System.Data.IDbCommand,System.Boolean,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Return an enumerable which uses lazy loading of each row.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="ownsConnection">
                <c>true</c> if the connection should be disposed together with the command/datareader. See
                remarks.
            </param>
            <param name="mapper">Mapper which convert a db row to an entity</param>
            <returns>Lazy loaded enumerator</returns>
            <remarks>
                <para>
                    The returned enumerator will not map each row until it's requested. To be able to do that the
                    connection/command/datareader is
                    kept open until the enumerator is disposed. Hence it's important that you make sure that the enumerator is
                    disposed when you are
                    done with it.
                </para>
                <para>
                    As the returned item is a custom lazy loaded enumerable it's quite fast as nothing is mapped if you do like:
                </para>
                <example>
                    <code>
            <![CDATA[
            using (var cmd = connection.CreateCommand())
            {
                cmd.CommandText = "SELECT * FROM Users";
                var pagedUsers = cmd.ToEnumerable<User>().Skip(1000).Take(50).ToList();
            }
            ]]>
            </code>
                </example>
                <para>
                    Do note that it will still read all rows and is therefore slower than paging in the SQL server. It will however
                    use a lot less
                    allocations than building a complete list first.
                </para>
                <para>
                    If the result returnd from the query is all records that you want it's probably more effecient to use
                    <see cref="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)"/>.
                </para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public TimeSpan CalculateWorkHours()
            {
                int minutes = 0;
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE Id = @id";
                    cmd.AddParameter("id", userId);
            
                    // can contain a large amount of rows without consuming memory
                    using (var incidents = cmd.ToEnumerable<Incident>())
                    {
                        foreach (var incident in incidents)
                        {
                            if (!incident.IsStarted)
                                continue;
            
                            var spentTime = incident.ReportedTime.Sum(x => x.TotalSpentTime);
                            minutes += spentTime;
                        }
                    }
                }
            
                return TimeSpan.FromMinutes(minutes);
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand)">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <returns>A collection of entities, or an empty collection if no entities are found.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindByName(string firstName, string lastName)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE ";
                    if (lastName != null)
                    {
                        cmd.AddParameter("firstName", firstName + "%");
                        cmd.CommandText += "FirstName LIKE @firstName AND ";
                    }
                    if (lastName != null)
                    {
                        cmd.AddParameter("lastName", lastName + "%");
                        cmd.CommandText += "LastName LIKE @lastName AND ";
                    }
            
                    cmd.CommandText = cmd.CommandText.Remove(cmd.CommandText.Length - 4, 4);
                    return cmd.ToList<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.CommandExtensions.ToList``1(System.Data.IDbCommand,Griffin.Data.Mapper.IEntityMapper{``0})">
            <summary>
                Generate a complete list before returning.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="cmd">Command to invoke <c>ExecuteReader()</c> on.</param>
            <param name="mapper">Mapper to use when converting the rows to entities</param>
            <returns>A collection of entities, or an empty collection if no entities are found.</returns>
            <example>
                <code>
            <![CDATA[
            public void FindByName(string firstName, string lastName)
            {
                using (var command = connection.CreateCommand())
                {
                    cmd.CommandText = "SELECT * FROM Users WHERE ";
                    if (lastName != null)
                    {
                        cmd.AddParameter("firstName", firstName + "%");
                        cmd.CommandText += "FirstName LIKE @firstName AND ";
                    }
                    if (lastName != null)
                    {
                        cmd.AddParameter("lastName", lastName + "%");
                        cmd.CommandText += "LastName LIKE @lastName AND ";
                    }
            
                    cmd.CommandText = cmd.CommandText.Remove(cmd.CommandText.Length - 4, 4);
                    return cmd.ToList<User>();
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.ConnectionExtensions">
            <summary>
            Synchronous connection extensions.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.First``1(System.Data.IDbConnection,System.Object)">
            <summary>
                Fetches the first row from a query, but mapped as an entity.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to create and execute our command on.</param>
            <param name="constraints">dynamic specifying the properties to use. All constraints are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Entity</returns>
            <exception cref="T:Griffin.Data.EntityNotFoundException">Failed to find entity</exception>
            <remarks>
                <para>Use this method when an entity is expected to be returned.</para>
            </remarks>
            <example>
                <code>
            <![CDATA[
            public User GetUser(string id)
            {
                return _connection.First<User>(new { FirstName = "Jonas", LastName = "Gauffin" });
            }
            ]]>
            </code>
            <para>Alternative two (works exactly like the example above).</para>
            <code>
            <![CDATA[
            public User GetUser(User user)
            {
                return _connection.First<User>(new { user.FirstName, user.LastName });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.FirstOrDefault``1(System.Data.IDbConnection,System.Object)">
            <summary>
                Fetches the first row and maps it as an entity (if found).
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to create and execute a command on.</param>
            <param name="constraints">dynamic specifying the properties to use. All constraints are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <returns>Entity if found; otherwise <c>null</c>.</returns>
            <example>
                <code>
            <![CDATA[
            public User GetUser(string id)
            {
                return _connection.FirstOrDefault<User>(new { FirstName = "Jonas", LastName = "Gauffin" });
            }
            ]]>
            </code>
            <para>Alternative two (works exactly like the example above).</para>
            <code>
            <![CDATA[
            public User GetUser(User user)
            {
                return _connection.FirstOrDefault<User>(new { user.FirstName, user.LastName });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Truncate``1(System.Data.IDbConnection)">
            <summary>
            Truncate a table (remove all rows)
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection to create and execute our command on</param>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Insert``1(System.Data.IDbConnection,``0)">
            <summary>
            Insert a new row into the database.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Connection create and execute our command on.</param>
            <param name="entity">entity to insert into the database.</param>
            <remarks>
            <para>
            Will assign the PK value to the 
            </para>
            </remarks>
            <example>
            <code>
            var user = new User(10, "Jonas");
            connection.Insert(user);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Update``1(System.Data.IDbConnection,``0)">
            <summary>
            Update an entity
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Transaction wrapper</param>
            <param name="entity">Entity to update</param>
            <returns>Task to wait on for completion</returns>
            <example>
            <code>
            var user = connection.First(new { Id = 1 });
            user.State = AccountState.Banned;
            connection.Update(user);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Delete``1(System.Data.IDbConnection,``0)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Unit of work to execute command in.</param>
            <param name="entity">Uses the primary key column(s), as defined in the mapping, to remove the entry.</param>
            <example>
            <code>
            <![CDATA[
            public void DeleteUser(int userId)
            {
                connection.Delete(new User { Id = userId });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.Delete``1(System.Data.IDbConnection,System.Object)">
            <summary>
            DELETE a row from the table.
            </summary>
            <typeparam name="TEntity">Type of entity to use, must have an mapper registered in <see cref="T:Griffin.Data.Mapper.EntityMappingProvider"/>.</typeparam>
            <param name="connection">Unit of work to execute command in.</param>
            <param name="constraints"><c>dynamic</c> specifying the properties to use. All parameters are joined with "AND" in the resulting SQL query. Any parameter with '%' in the value will be using LIKE instead of '='</param>
            <example>
            <code>
            <![CDATA[
            public void DeleteUser(int userId)
            {
                connection.Delete(new { Id = userId });
            }
            ]]>
            </code>
            <para>Alternative syntax:</para>
            <code>
            <![CDATA[
            public void DeleteUser(SomeDTO dto)
            {
                connection.Delete(new { dto.Id });
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.ConnectionExtensions.ExecuteNonQuery(System.Data.IDbConnection,System.String,System.Object)">
            <summary>
            Execute a query directly
            </summary>
            <param name="connection">Connection to execute query on</param>
            <param name="sql">sql query</param>
            <param name="parameters">parameters used in the query</param>
            <remarks>
            <para>Do note that the query must be using table column names and not class properties. No mapping is being made.</para>
            <para><c>null</c> is automatically replaced by <c>DBNull.Value</c> for the parameters</para>
            </remarks>
            <example>
            <code>
            public void Execute(IDbConnection connection)
            {
                connection.ExecuteNonQuery("UPDATE Users SET Discount = Discount + 10 WHERE OrganizationId = @orgId", new { orgId = 10});
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.DateTimeExtensions">
            <summary>
            Some databases do not support DateTime columns. For them we can instead store an unix time integer. These extensions handles the conversions for us.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.ToUnixTime(System.DateTime)">
            <summary>
            Convert a date to unix epoch
            </summary>
            <param name="dateUtc">MUST be in UTC. Either use <c>DateTime.UtcNow</c> or convert the local time to UTC time.</param>
            <returns>Seconds from 1970-01-01</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.FromUnixTime(System.Double)">
            <summary>
            Convert unix time to a DateTime struct
            </summary>
            <param name="unixTime">Seconds from 1970-01-01</param>
            <returns>Date/time in UTC time zone</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.DateTimeExtensions.FromUnixTime(System.Int32)">
            <summary>
            Convert unix time to a DateTime struct
            </summary>
            <param name="unixTime">Seconds from 1970-01-01</param>
            <returns>Date/time in UTC time zone</returns>
        </member>
        <member name="T:Griffin.Data.Mapper.EntityMapper`1">
            <summary>
                Uses reflection to map entities.
            </summary>
            <typeparam name="TEntity">Type of entity (i.e. class that somewhat corresponds to a table)</typeparam>
            <remarks>
            <para>
            This mapper is konventional based. If there is a column named <c>"Id"</c> this mapper will assume that that is the primary key. If you do not have
            an <c>"Id"</c> id column you need to inherit this class and overide the <c>Configure</c> method:
            </para>
            <code>
            <![CDATA[
            public class UserMapping : EntityMapper<User>
            {
                public override void Configure(IDictionary<string, PropertyMapping> mappings)
                {
                    base.Configure(mappings);
            
                    mappings["YourCustomKey"].IsPrimaryKey = true;
                }
            }
            ]]>
            </code>
                <para>
                    All mappers must have a parameterless constructor, but you can set it as non-public if you do not want to expose
                    it.
                </para>
                <para>
                </para>
            </remarks>
            <example>
                <para>
                    You can just create an empty class like below if there is an one-one mapping between the table and your entity class. It will
                    automatically be
                    picked up by the <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/>.
                </para>
                <code>
            <![CDATA[
            public class UserMapping : EntityMapper<User>
            {
            }
            ]]>
            </code>
                <para>You can also customize the mappings</para>
                <code>
            <![CDATA[
            public class UserMapping : EntityMapper<User>
            {
                public override void Configure(IDictionary<string, PropertyMapping> mappings)
                {
                    base.Configure(mappings);
            
                    // Id is of the column type "uniqueidentifier" in the DB and of "string" type for our property.
                    mappings["Id"].ColumnToPropertyAdapter = value => value.ToString();
                    mappings["Id"].PropertyToColumnAdapter = value => Guid.Parse(string)value);
                }
            }
            ]]>
            </code>
                <para>Look at the <see cref="M:Griffin.Data.Mapper.EntityMapper`1.Configure(System.Collections.Generic.IDictionary{System.String,Griffin.Data.Mapper.IPropertyMapping})"/> documentation for more examples.</para>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.IEntityMapper`1">
            <summary>
            Generic version of the mapping method to make it easier to do mappings manually.
            </summary>
            <typeparam name="TEntity">Type of entity</typeparam>
            <remarks>
            <para>
            Important! The implementations of this interface should be considered to be singletons. Hence any state in them
            must be thread safe. The same instance can be used to map multiple entities at the same time.
            </para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            public class UserMapper : IEntityMapper<User>
            {
                public object Create(IDataRecord source)
                {
                    return new User();
                }
            
                public void Map(IDataRecord source, User destination)
                {
                    destination.Id = source["Id"].ToString();
                    destination.Age = (int)source["Age"];
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.IEntityMapper">
            <summary>
            Maps a table column to a .NET entity.
            </summary>
            <remarks>
            <para>
            Important! The implementations of this interface should be considered to be singletons. Hence any state in them
            must be thread safe. The same instance can be used to map multiple entities at the same time.
            </para>
            <para>
            You have to decorate class that implement this interface with the <see cref="T:Griffin.Data.Mapper.MappingForAttribute"/> to tell the scanner
            which entity the class is a mapping for.
            </para>
            </remarks>
            <example>
            <code>
            <![CDATA[
            [MappingFor(typeof(User))
            class UserMapper : IEntityMapper<User>
            {
                public object Create(IDataRecord source)
                {
                    return new User();
                }
            
                public void Map(IDataRecord source, object destination)
                {
                    var user = (User)destination;
                    user.Id = source["Id"].ToString();
                    user.Age = (int)source["Age"];
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper.Create(System.Data.IDataRecord)">
            <summary>
            Create a new entity for the specified 
            </summary>
            <param name="record">should only be used to initialize any constructor arguments.</param>
            <returns>Created entity</returns>
            <example>
            <para>Where a default constructor exists:</para>
            <code>
            public object Create(IDataRecord record)
            {
                return new User();
            }
            </code>
            <para>Where a only constructors with arguments exists:</para>
            <code>
            public object Create(IDataRecord record)
            {
                return new User(record["Id"].ToString());
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper.Map(System.Data.IDataRecord,System.Object)">
            <summary>
            Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
            <example>
            <code>
            public void Map(IDataRecord source, object destination)
            {
                var user = (User)destination;
                user.Id = source["Id"].ToString();
                user.Age = (int)source["Age"];
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper.Freeze">
            <summary>
            Free the mapping, no further changes may be made.
            </summary>
            <remarks>
            <para>Called by the mapping provider when it's being added to it.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper.GetKeys(System.Object)">
            <summary>
            Get the primary key 
            </summary>
            <param name="entity">Entity to fetch key values from</param>
            <returns>A single item in the array for a single PK column and one entry per column in composite primary key</returns>
            <example>
            <para>If you have a single primary key (like an auto incremented column)</para>
            <code>
            <![CDATA[
            var user = new User { Id = 24, Name = "Jonas" };
            var mapping = new EntityMapping<User>();
            var pk = mapping.GetKeys(user);
            
            Console.WriteLine(pk[0].Name + " = " + pk[0].Value); // prints "Id = 24"
            ]]>
            </code>
            <para>
            A composite key:
            </para>
            <code>
            <![CDATA[
            var address = new UserAddress{ UserId = 24, ZipCode  = "1234", City = "Falun" };
            var mapping = new EntityMapping<UserAddress>();
            var pk = mapping.GetKeys(address);
            
            Console.WriteLine(pk[0].Value + ", " + pk[1].Value); // prints "24, 1234"
            ]]>
            </code>
            </example>
        </member>
        <member name="P:Griffin.Data.Mapper.IEntityMapper.TableName">
            <summary>
            Gets table name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IEntityMapper.Properties">
            <summary>
            All properties in this mapping
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IEntityMapper.CommandBuilder">
            <summary>
            Used to create SQL commands which is specific for this entity.
            </summary>
            <remarks>
            <para>The recommended approach for implementations is to retrieve the command builder from <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory"/> when the <c>Freeze()</c> method is being invoked.
            By doing so it's easy to adapt and precompile the command strings and logic before any invocations is made.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.IEntityMapper`1.Map(System.Data.IDataRecord,`0)">
            <summary>
            Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
            <example>
            <code>
            public void Map(IDataRecord source, User destination)
            {
                destination.Id = source["Id"].ToString();
                destination.Age = (int)source["Age"];
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Griffin#Data#Mapper#IEntityMapper#Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Freeze">
            <summary>
                Free the mapping, no further changes may be made.
            </summary>
            <remarks>
                <para>Called by the mapping provider when it's being added to it.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.GetKeys(System.Object)">
            <summary>
            Get the primary key 
            </summary>
            <param name="entity">entity to fetch key values from.</param>
            <returns>A single item in the array for a single PK column and one entry per column in composite primary key</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Map(System.Data.IDataRecord,`0)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Configure(System.Collections.Generic.IDictionary{System.String,Griffin.Data.Mapper.IPropertyMapping})">
            <summary>
                Used to map all properties which should be read from the database record.
            </summary>
            <param name="mappings">Dictionary which should be filled with all mappings</param>
            <remarks>
                <para>
                    Will scan all properties and assign them a mapping, even if the setters are non-public. If no setter is
                    available
                    it will try to finding a field using the name convention where <c>FirstName</c> becomes <c>_firstName</c>.
                </para>
            </remarks>
            <example>
                <para>If you want to remove a property:</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings.Remove("CreatedAt");
            }
            ]]>
            </code>
                <para>Example if the column type is <c>uniqueidentifier</c> and the property type is string:</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings["Id"].ColumnToPropertyAdapter = value => value.ToString();
            }
            ]]>
            </code>
                <para>If you have stored a child aggregate as a JSON string in a column</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings["AuditLog"].ColumnToPropertyAdapter = value => JsonConvert.ToObject<IEnumerable<AuditEntry>>(value.ToString());
            }
            ]]>
            </code>
                <para>To convert an int column in the db to an enum</para>
                <code>
            <![CDATA[
            public override void Configure(IDictionary<string, PropertyMapping> mappings)
            {
                base.Configure(mappings);
                mappings["State"].ColumnToPropertyAdapter = value => (UserState)value;
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapper`1.Create(System.Data.IDataRecord)">
            <summary>
                Create a new entity for the specified
            </summary>
            <param name="record">Data record that we are going to map</param>
            <returns>Created entity</returns>
            <remarks>
                <para>
                    The provided record should only be used if there are constructor arguments.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapper`1.TableName">
            <summary>
                Gets table name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapper`1.Properties">
            <summary>
                All properties in this mapping
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapper`1.CommandBuilder">
            <summary>
                Used to create SQL commands which is specific for this entity.
            </summary>
            <remarks>
                <para>
                    The recommended approach for implementations is to retrieve the command builder from
                    <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory"/> when the <c>Freeze()</c> method is being invoked.
                    By doing so it's easy to adapt and precompile the command strings and logic before any invocations is made.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.EntityMapperBase`1">
            <summary>
                Used to map a <see cref="T:System.Data.IDataRecord"/> to an entity.
            </summary>
            <remarks>
                <para>Just hides the non generic methods from the public contract.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapperBase`1.Create(System.Data.IDataRecord)">
            <summary>
                Create a new entity for the specified
            </summary>
            <param name="record">Data record that we are going to map</param>
            <returns>Created entity</returns>
            <remarks>
                <para>
                    The provided record should only be used if there are constructor arguments.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapperBase`1.Griffin#Data#Mapper#IEntityMapper#Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapperBase`1.Freeze">
            <summary>
            Free the mapping, no further changes may be made.
            </summary>
            <remarks>
            <para>Called by the mapping provider when it's being added to it.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapperBase`1.GetKeys(System.Object)">
            <summary>
            Get the primary key 
            </summary>
            <param name="entity"></param>
            <returns>A single item in the array for a single PK column and one entry per column in composite primary key</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapperBase`1.Map(System.Data.IDataRecord,`0)">
            <summary>
                Map a record to the specified entity
            </summary>
            <param name="source">Record from the DB</param>
            <param name="destination">Entity to fill with information</param>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMapperBase`1.Griffin#Data#Mapper#IEntityMapper#Create(System.Data.IDataRecord)">
            <summary>
                Create a new entity for the specified
            </summary>
            <param name="record">Data record that we are going to map</param>
            <returns>Created entity</returns>
            <remarks>
                <para>
                    The provided record should only be used if there are constructor arguments.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapperBase`1.TableName">
            <summary>
            Gets table name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapperBase`1.Properties">
            <summary>
            All properties in this mapping
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMapperBase`1.CommandBuilder">
            <summary>
            Used to create SQL commands which is specific for this entity.
            </summary>
            <remarks>
            <para>The recommended approach for implementations is to retrieve the command builder from <see cref="T:Griffin.Data.Mapper.CommandBuilders.CommandBuilderFactory"/> when the <c>Freeze()</c> method is being invoked.
            By doing so it's easy to adapt and precompile the command strings and logic before any invocations is made.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Data.Mapper.EntityMappingProvider">
            <summary>
                Facade for the current <see cref="T:Griffin.Data.Mapper.IMappingProvider"/> implementation.
            </summary>
            <remarks>
                <para>
                    This facade exists so that no code needs to be refactored if the mapping provider is replace with another
                    one.
                </para>
                <para>
                    The <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/> is used per default (if no other provider is assigned). It
                    is lazy loaded so that
                    all assemblies have a chance to be loaded before it scans all assemblies in the current appdomain.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.EntityMappingProvider.GetMapper``1">
            <summary>
                Get a mapper.
            </summary>
            <typeparam name="TEntity">Type of entity to get a mapper for.</typeparam>
            <exception cref="T:Griffin.Data.Mapper.MappingNotFoundException">Did not find a mapper for the specified entity.</exception>
            <returns></returns>
        </member>
        <member name="P:Griffin.Data.Mapper.EntityMappingProvider.Provider">
            <summary>
                Provider to use.
            </summary>
            <value>
                Default is <see cref="T:Griffin.Data.Mapper.AssemblyScanningMappingProvider"/>. Read the class remarks for more information.
            </value>
        </member>
        <member name="M:Griffin.Data.Mapper.IPropertyMapping.Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Convert the value in the specified record and assign it to the property in the specified instance
            </summary>
            <param name="source">Database record</param>
            <param name="destination">Entity instance</param>
            <remarks>
            <para>Will exit the method without any assignment if the value is <c>DBNull.Value</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.IPropertyMapping.GetValue(System.Object)">
            <summary>
            Get property value
            </summary>
            <param name="entity">Entity to retrieve value from</param>
            <returns>Property value</returns>
        </member>
        <member name="M:Griffin.Data.Mapper.IPropertyMapping.SetColumnValue(System.Object,System.Object)">
            <summary>
            Set property value by specifying a column value (i.e. use the <c>ColumnToPropertyAdapter</c> when assigning the value)
            </summary>
            <param name="entity">Entity to retrieve value from</param>
            <param name="value">Column value</param>
            <returns>Property value</returns>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.ColumnToPropertyAdapter">
            <summary>
                Used to convert the database value to the type used by the property
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.PropertyToColumnAdapter">
            <summary>
                Used to convert the property to the type used by the column.
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.PropertyName">
            <summary>
                Name of the property in the entity
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.IPropertyMapping.ColumnName">
            <summary>
                Set if the column name is different from the property name
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.MappingException">
            <summary>
            We did not have a mapping configured for an entity type.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown. </param><param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination. </param><exception cref="T:System.ArgumentNullException">The <paramref name="info"/> parameter is a null reference (Nothing in Visual Basic). </exception><filterpriority>2</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*"/><IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter"/></PermissionSet>
        </member>
        <member name="P:Griffin.Data.Mapper.MappingException.EntityTypeName">
            <summary>
            Full name of the entity type that we did not have a mapping for.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.MappingForAttribute">
            <summary>
                Will point on the entity that a mapping is for if the <see cref="T:Griffin.Data.Mapper.IEntityMapper"/> interface is used instead of the
                generic one.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.MappingForAttribute.#ctor(System.Type)">
            <summary>
            </summary>
            <param name="entityType"></param>
        </member>
        <member name="P:Griffin.Data.Mapper.MappingForAttribute.EntityType">
            <summary>
                Type of entity that the decorated entity mapper is for.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.MappingNotFoundException">
            <summary>
            We did not have a mapping configured for an entity type.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.NamespaceDoc">
            <summary>
            Micro data layer making it easier to work with SQL queries.
            </summary>
            <remarks>
            <para></para>
            The command extension uses mapper classes
            to map the database recordset to your entity classes. Hence you need to start by creating mappings as shown below. 
            <para>
            The mappings are retrieve by using the Assem
            </para>
            </remarks>
            <example>
            <para>First you have to define one mapping file per entity that you want to fetch. The following mapping
            works when the columns are named same as the class properties and they are of the same type:</para>
            <code>
            <![CDATA[
            public class UserMapping : ReflectionBasedEntityMapper<User>
            {
            }
            ]]>
            </code>
            <para>You can however customize it to specify a different column name or use an adapter for the column value. Read more in the <see cref="!:ReflectionEntityMapper&lt;TEntity&gt;"/> documentation.</para>
            </example>
        </member>
        <member name="T:Griffin.Data.Mapper.PropertyMapping`1">
            <summary>
                Used to convert the database column value and assign it to the property/field in the entity.
            </summary>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.#ctor(System.String,System.Action{`0,System.Object},System.Func{`0,System.Object})">
            <summary>
            
            </summary>
            <param name="propertyName"></param>
            <param name="setter"></param>
            <param name="getter"></param>
            <example>
            <code>
            var mapping = new PropertyMapping("Id", (instance, value) => ((User)instance).Id = (string)value);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.Map(System.Data.IDataRecord,`0)">
            <summary>
                Convert the value in the specified record and assign it to the property in the specified instance
            </summary>
            <param name="source">Database record</param>
            <param name="destination">Entity instance</param>
            <remarks>
            <para>Will exit the method without any assignment if the value is <c>DBNull.Value</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.Griffin#Data#Mapper#IPropertyMapping#Map(System.Data.IDataRecord,System.Object)">
            <summary>
                Convert the value in the specified record and assign it to the property in the specified instance
            </summary>
            <param name="source">Database record</param>
            <param name="destination">Entity instance</param>
            <remarks>
            <para>Will exit the method without any assignment if the value is <c>DBNull.Value</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.Mapper.PropertyMapping`1.SetColumnValue(System.Object,System.Object)">
            <summary>
            Set property value by specifying a column value (i.e. use the <c>ColumnToPropertyAdapter</c> when assigning the value)
            </summary>
            <param name="entity">Entity to retrieve value from</param>
            <param name="value">Column value</param>
            <returns>Property value</returns>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.CanWrite">
            <summary>
            Determines if this property can be written to
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.CanRead">
            <summary>
            Determines if this property can be read
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.IsPrimaryKey">
            <summary>
            This property is a primary key
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.PropertyName">
            <summary>
                Name of the property in the entity
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.ColumnName">
            <summary>
                Set if the column name is different from the property name
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.ColumnToPropertyAdapter">
            <summary>
                Used to convert the database value to the type used by the property
            </summary>
        </member>
        <member name="P:Griffin.Data.Mapper.PropertyMapping`1.PropertyToColumnAdapter">
            <summary>
                Used to convert the property to the type used by the column.
            </summary>
        </member>
        <member name="T:Griffin.Data.Mapper.ValueHandler">
            <summary>
                Used by the adapters in <see cref="T:Griffin.Data.Mapper.PropertyMapping`1"/>.
            </summary>
            <param name="originalValue">Value from column or property depending on the mapping direction</param>
            <returns>Modified value</returns>
        </member>
        <member name="T:Griffin.Data.NamespaceDoc">
            <summary>
            
            </summary>
        </member>
        <member name="T:Griffin.Data.TransactionAlreadyClosedException">
            <summary>
                A transaction have already been closed.
            </summary>
            <remarks>
                <para>
                    Usually thrown if you have a messy data model where you do not have a full control over how a transaction is
                    created and/or commited.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Data.TransactionAlreadyClosedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with
                information about the exception.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual
                information about the source or destination.
            </param>
            <exception cref="T:System.ArgumentNullException">
                The <paramref name="info" /> parameter is a null reference (Nothing in
                Visual Basic).
            </exception>
            <filterpriority>2</filterpriority>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="SerializationFormatter" />
            </PermissionSet>
        </member>
        <member name="T:Griffin.Data.UnitOfWorkFactory">
            <summary>
                Can be used to create unit of work instances in your application.
            </summary>
            <example>
                <para>Assignment:</para>
                <code>
            public IUnitOfWork Create()
            {
                var conString = ConfigurationManager.ConnectionStrings("MyDb").ConnectionString;
                var con = new SqlConnection(conString);
                con.Open();
                return new AdoNetUnitOfWork(con, true);
            }
            
            UnitOfWorkFactory.SetFactoryMethod(() => Create());
            </code>
                <para>Usage:</para>
                <code>
            using (var uow = UnitOfWorkFactory.Create())
            {
                var repos = new UserRepository(uow);
                repos.Create("Jonas");
            
                uow.SaveChanges();
            }
            </code>
            </example>
        </member>
        <member name="M:Griffin.Data.UnitOfWorkFactory.Create">
            <summary>
            Create a new unit of work.
            </summary>
            <returns>Created UOW</returns>
        </member>
        <member name="M:Griffin.Data.UnitOfWorkFactory.SetFactoryMethod(System.Func{Griffin.Data.IUnitOfWork})">
            <summary>
                Assign a method which will be used to create an unit of work every time <c>Create()</c> is being called.
            </summary>
            <param name="factoryMethod">Should return a fully functional UoW.</param>
        </member>
        <member name="T:Griffin.External.Inflector.Inflector">
            <summary>
                From: https://github.com/srkirkland/Inflector
                License: MIT
            </summary>
        </member>
        <member name="T:Griffin.GuidFactory">
            <summary>
                Produce GUIDs with are used internally in this library
            </summary>
            <remarks>
                <para>
                    Can be used to use specialized guids as COMBs to increase performance of data source lookups.
                </para>
                <para>The default implementation uses <c>Guid.NewGuid()</c>.</para>
            </remarks>
        </member>
        <member name="M:Griffin.GuidFactory.Assign(Griffin.GuidFactory)">
            <summary>
                Assign a new factory
            </summary>
            <param name="factory">Factory to use</param>
        </member>
        <member name="M:Griffin.GuidFactory.Create">
            <summary>
                Generate a new GUID
            </summary>
            <returns>Guid of some sort.</returns>
        </member>
        <member name="M:Griffin.GuidFactory.CreateInternal">
            <summary>
                Generate a new GUID using the assign implementation
            </summary>
            <returns>Guid of some sort</returns>
        </member>
        <member name="T:Griffin.InstanceFactory">
            <summary>
            Delegate returned by <see cref="M:Griffin.ConstructorExtensions.CreateFactory(System.Reflection.ConstructorInfo)"/>.
            </summary>
            <param name="args">Constructor arguments</param>
            <returns>Created object</returns>
        </member>
        <member name="T:Griffin.IO.PersistentCircularIndex">
            <summary>
                A circular index.
            </summary>
            <remarks>
                <para>
                    Stores an index file on disk which is intended for a queue with a known size. The implementation works like a
                    circular queue where there are two pointers defined
                    in the file, one for the next read position and one for the next write position. In that way we can minimize
                    the number of reads required to read/write from the
                    file.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.IO.PersistentQueue`1">
            <summary>
            Used to store items on disk
            </summary>
            <typeparam name="T">Type of item to store, may be a base type.</typeparam>
        </member>
        <member name="T:Griffin.IQueue`1">
            <summary>
            A queue definition
            </summary>
            <typeparam name="T">Type of entity to store in the queue</typeparam>
        </member>
        <member name="M:Griffin.IQueue`1.DequeueAsync">
            <summary>
            Dequeue an item from our queue.
            </summary>
            <returns>Dequeued item; <c>default(T)</c> if there are no more items in the queue.</returns>
        </member>
        <member name="M:Griffin.IQueue`1.EnqueueAsync(`0)">
            <summary>
            Enqueue item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.IO.PersistentQueue`1.#ctor(Griffin.IO.PersistentQueueConfiguration)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.IO.PersistentQueue`1"/> class.
            </summary>
            <exception cref="T:System.ArgumentNullException">dataDirectory</exception>
        </member>
        <member name="T:Griffin.IO.Serializers.BinaryFormatterSerializer">
            <summary>
            Wraps around <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter"/>.
            </summary>
        </member>
        <member name="T:Griffin.ISerializer">
            <summary>
                Serialize/deserialize an object
            </summary>
        </member>
        <member name="M:Griffin.ISerializer.Serialize(System.Object,System.IO.Stream)">
            <summary>
                Servialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Failed to serialize object</exception>
        </member>
        <member name="M:Griffin.ISerializer.Serialize(System.Object,System.IO.Stream,System.Type)">
            <summary>
                Servialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
            <param name="baseType">
                If specified, we should be able to differentiate sub classes, i.e. include type information if
                <c>source</c> is of another type than this one.
            </param>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Failed to serialize object</exception>
        </member>
        <member name="M:Griffin.ISerializer.Deserialize(System.IO.Stream,System.Type)">
            <summary>
                Deserialize a stream
            </summary>
            <param name="source">Stream to read from</param>
            <param name="targetType">Type to deserialize. Should be the base type if inheritance is used.</param>
            <returns>Serialized object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Failed to deserialize object</exception>
        </member>
        <member name="M:Griffin.IO.Serializers.BinaryFormatterSerializer.Serialize(System.Object,System.IO.Stream)">
            <summary>
            Servialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
        </member>
        <member name="M:Griffin.IO.Serializers.BinaryFormatterSerializer.Serialize(System.Object,System.IO.Stream,System.Type)">
            <summary>
            Servialize
            </summary>
            <param name="source">object to serialize</param>
            <param name="destination">Stream to write to</param>
            <param name="baseType">If specified, we should be able to differentiate sub classes, i.e. include type information if
            <c>source</c> is of another type than this one.</param>
        </member>
        <member name="M:Griffin.IO.Serializers.BinaryFormatterSerializer.Deserialize(System.IO.Stream,System.Type)">
            <summary>
            Deserialize a stream
            </summary>
            <param name="source">Stream to read from</param>
            <param name="targetType">Type to deserialize. Should be the base type if inheritance is used.</param>
            <returns>
            Serialized object
            </returns>
        </member>
        <member name="T:Griffin.IO.PersistentQueueConfiguration">
            <summary>
            Configuration options for <see cref="T:Griffin.IO.PersistentQueue`1"/>.
            </summary>
        </member>
        <member name="M:Griffin.IO.PersistentQueueConfiguration.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.IO.PersistentQueueConfiguration"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
            <exception cref="T:System.ArgumentNullException">queueName</exception>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.MaxCount">
            <summary>
            Max amount of items in the queue
            </summary>
            <remarks>
            <para>
            The implementation is using a circular index file where all records are pre-created. You therefore have to specify the maximum amount of items that can be in the queue. The index
            file is approximely 32 bytes * MaxCount bytes large. i.e. 1000 records means a 32 000 bytes large index file.
            </para>
            </remarks>
            <value>
            Default is 100.
            </value>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.QueueName">
            <summary>
            Name of the queue
            </summary>
            <remarks>
            <para>
            A sub directory will be created with this name and the index file will also be named as the specified name.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.DataDirectory">
            <summary>
            
            </summary>
            <example>
            <para>You can get a windows folder by doing like this:</para>
            <code>
             var path = Environment.GetFolderPath(rootFolder);
             path = Path.Combine(path, @"MyAppName\Queues");
            
             config.DataDirectory = path;
            </code>
            </example>
            <value>
            Default is <c>Path.GetTempPath()</c>
            </value>
        </member>
        <member name="P:Griffin.IO.PersistentQueueConfiguration.Serializer">
            <summary>
            Kind of serializer to use.
            </summary>
            <remarks>
            <para>
            Install the nuget package <c>Griffin.Framework.Json</c> if you would like to use JSON.NET.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.ILogEntryFilter">
            <summary>
                Decides which log entries each logger should accept.
            </summary>
            <remarks>
                <para>
                    The logging library can use to types of filters. Logger filters which decide which log each type should write
                    to. The other kind of filters are implemented by this class: Once a logger receives a log entry, these filters
                    are used to determine which log entry can be logged.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.ILogEntryFilter.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
                Check if the logger may write this entry.
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns><c>true</c> if the entry can be written; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Griffin.Logging.ILogger">
            <summary>
            Logging interface
            </summary>
            <remarks>You typically just want to log the warnings and the errors from the framework since your logs
            will probably be filled very quickly otherwise.</remarks>
        </member>
        <member name="M:Griffin.Logging.ILogger.Trace(System.String,System.Object[])">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Debug(System.String,System.Object[])">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Info(System.String,System.Object[])">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Warning(System.String,System.Object[])">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Error(System.String,System.Object[])">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.ILogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write a previously created log instance.
            </summary>
            <param name="entry">Entry to write to the logfile.</param>
        </member>
        <member name="T:Griffin.Logging.ILoggerFilter">
            <summary>
                Used to determine which loggers a specific type can log to.
            </summary>
        </member>
        <member name="M:Griffin.Logging.ILoggerFilter.IsSatisfiedBy(System.Type)">
            <summary>
                Checks if the specified logger may log to a certain logger.
            </summary>
            <param name="typeThatWantToLog">Type that want's to write to a log.</param>
            <returns><c>true</c> if the logging type is acceptable by this filter; otherwise <c>false</c>.</returns>
        </member>
        <member name="T:Griffin.Logging.ILogProvider">
            <summary>
            Factory which produces loggers when requested.
            </summary>
        </member>
        <member name="M:Griffin.Logging.ILogProvider.GetLogger(System.Type)">
            <summary>
            Create a new logger.
            </summary>
            <param name="typeThatWantToLog">Type which want's to write to the log file</param>
            <returns>Logger to use (must not be <c>null</c>).</returns>
        </member>
        <member name="T:Griffin.Logging.LogEntry">
            <summary>
            Entry to write
            </summary>
        </member>
        <member name="M:Griffin.Logging.LogEntry.#ctor(Griffin.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.LogEntry"/> class.
            </summary>
            <param name="logLevel">The log level, see the enum for a detail description of each level..</param>
            <param name="message">Message written by the dev.</param>
            <param name="exception">exception (if any).</param>
            <exception cref="T:System.ArgumentNullException">message</exception>
        </member>
        <member name="P:Griffin.Logging.LogEntry.WrittenAt">
            <summary>
            When the log entry was written
            </summary>
        </member>
        <member name="P:Griffin.Logging.LogEntry.LogLevel">
            <summary>
            log level, see the enum for a detail description of each level
            </summary>
        </member>
        <member name="P:Griffin.Logging.LogEntry.Message">
            <summary>
            Message written by the dev
            </summary>
        </member>
        <member name="P:Griffin.Logging.LogEntry.Exception">
            <summary>
            Exception if any.
            </summary>
        </member>
        <member name="T:Griffin.Logging.Loggers.BaseLogger">
            <summary>
            Base class for loggers.
            </summary>
            <remarks>All you have to do is to override <see cref="M:Griffin.Logging.Loggers.BaseLogger.Write(Griffin.Logging.LogLevel,System.String,System.Exception)"/>.</remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.BaseLogger"/> class.
            </summary>
            <param name="typeThatLogs">Type of the class which uses this log. The type is used to write in the log file where the lines come from.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Trace(System.String,System.Object[])">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Debug(System.String,System.Object[])">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Debug(System.String,System.Exception)">
            <summary>
            Diagnostic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Info(System.String,System.Object[])">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Info(System.String,System.Exception)">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Warning(System.String,System.Object[])">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Error(System.String,System.Object[])">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Write(Griffin.Logging.LogLevel,System.String,System.Exception)">
            <summary>
            Checks our log filter and then calls the abstract method
            </summary>
            <param name="logLevel">Log level.</param>
            <param name="msg">Message to write.</param>
            <param name="exception">The exception (or null).</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
            Write entry to the destination.
            </summary>
            <param name="entry">Entry to write</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.BaseLogger.BuildExceptionDetails(System.Exception,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats exception details (including all inner exceptions)
            </summary>
            <param name="exception">Thrown exception.</param>
            <param name="spaces">Number of spaces to prefix each line with.</param>
            <param name="result">The created information will be appended to this string builder.</param>
            <remarks>Increases the number of spaces for each inner exception so it's easy to see all information</remarks>
        </member>
        <member name="P:Griffin.Logging.Loggers.BaseLogger.LoggedType">
            <summary>
            Gets the type for the class which logs using this class
            </summary>
        </member>
        <member name="T:Griffin.Logging.Loggers.CompositeLogger">
            <summary>
                Can be used to write to several logs in one run.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.CompositeLogger.#ctor(System.Type)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.CompositeLogger"/> class.
            </summary>
            <param name="typeThatLogs">
                Type of the class which uses this log. The type is used to write in the log file where the
                lines come from.
            </param>
        </member>
        <member name="M:Griffin.Logging.Loggers.CompositeLogger.Add(Griffin.Logging.ILogger)">
            <summary>
                Add another logger that each entry should be written to
            </summary>
            <param name="logger">Logger to write to</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.CompositeLogger.Write(Griffin.Logging.LogEntry)">
            <summary>
                Write entry to the destination.
            </summary>
            <param name="entry">Entry to write</param>
            <exception cref="T:System.ArgumentNullException">entry</exception>
        </member>
        <member name="T:Griffin.Logging.Loggers.ConsoleLogger">
            <summary>
            Log everything to the console
            </summary>
            <remarks>Prints one stack frame using colored output.</remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.ConsoleLogger"/> class.
            </summary>
            <param name="typeThatLogs">Type being logged.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.GetStackFrame">
            <summary>
            Used to get the correct frame when <see cref="P:Griffin.Logging.Loggers.ConsoleLogger.UseStackFrame"/> is set to true.
            </summary>
            <returns></returns>
            <remarks>
            <para>Will traverse all frames in the stack the first time this method is called. Will only get the correct frame all other times.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Loggers.ConsoleLogger.GetColor(Griffin.Logging.LogLevel)">
            <summary>
            Get a color for a specific log level
            </summary>
            <param name="logLevel">Level to get color for</param>
            <returns>Level color</returns>
        </member>
        <member name="P:Griffin.Logging.Loggers.ConsoleLogger.UseStackFrame">
            <summary>
            Specifies if we should use stack frame to identify the caller (instead of <c>loggedType</c>)
            </summary>
            <remarks>
            <para>Do note that there is a performance hit by using this class.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.ExceptionsOnly">
            <summary>
            Only allow entries that got exceptions
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.ExceptionsOnly.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
            Check if the entry have an exception
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns>
              <c>true</c> if the entry has an exception; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.LogLevelFilter">
            <summary>
                Filters on log level
            </summary>
            <example>
                <code>
            var logger = new ConsoleLogger();
            logger.LogFilter = new LogLevelFilter { MinLevel = LogLevel.Info };
            
            var provider = new LogProvider();
            provider.Add(logger);
            
            LogManager.Provider = provider;
            </code>
            </example>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.LogLevelFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.Filters.LogLevelFilter"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.LogLevelFilter.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
                Check if the logger may write this entry.
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns>
                <c>true</c> if the entry can be written; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:Griffin.Logging.Loggers.Filters.LogLevelFilter.MinLevel">
            <summary>
                Minimum level (inclusive)
            </summary>
            <value>
                Default is <see cref="F:Griffin.Logging.LogLevel.Debug"/>.
            </value>
        </member>
        <member name="P:Griffin.Logging.Loggers.Filters.LogLevelFilter.MaxLevel">
            <summary>
                Maximum level (inclusive)
            </summary>
            <value>
                Default is <see cref="F:Griffin.Logging.LogLevel.Error"/>.
            </value>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.NamespaceDoc">
            <summary>
                These filters are used to control which log entries are allowed in which logger.
            </summary>
            <remarks>
                <para>
                    You can for instance make sure that only entries with an exception is written to a file logger named
                    "exeptions.log";
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.Loggers.Filters.NoFilter">
            <summary>
                Can be used to disable filtering
            </summary>
        </member>
        <member name="F:Griffin.Logging.Loggers.Filters.NoFilter.Instance">
            <summary>
                Instance to use
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.NoFilter.#ctor">
            <summary>
                Prevents a default instance of the <see cref="T:Griffin.Logging.Loggers.Filters.NoFilter"/> class from being created.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.Filters.NoFilter.IsSatisfiedBy(Griffin.Logging.LogEntry)">
            <summary>
            Will always return true;
            </summary>
            <param name="logEntry">Entry that the user want to write</param>
            <returns>
              <c>true</c>, always.
            </returns>
        </member>
        <member name="T:Griffin.Logging.Loggers.NamespaceDoc">
            <summary>
                Loggers are the classes which writes log entries to the different destinations.
            </summary>
        </member>
        <member name="T:Griffin.Logging.Loggers.NullLogger">
            <summary>
            Throws away all logs
            </summary>
        </member>
        <member name="F:Griffin.Logging.Loggers.NullLogger.Instance">
            <summary>
            Singleton
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Trace(System.String,System.Object[])">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Trace(System.String,System.Exception)">
            <summary>
            Detailed framework messages used to find wierd errors.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Debug(System.String,System.Object[])">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Debug(System.String,System.Exception)">
            <summary>
            Diagonstic messages. Not as detailed as the trace messages but still only useful during debugging.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Info(System.String,System.Object[])">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Info(System.String,System.Exception)">
            <summary>
            Information messages are typically used when the application changes state somewhere.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Thrown exception</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Warning(System.String,System.Object[])">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Warning(System.String,System.Exception)">
            <summary>
            Something did not go as planned, but the framework can still continue as expected.
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Error(System.String,System.Object[])">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="formatters">Formatters used in the <c>message</c>.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.NullLogger.Error(System.String,System.Exception)">
            <summary>
            Something failed. The framework must abort the current processing
            </summary>
            <param name="message">Message to log</param>
            <param name="exception">Exception which has been thrown</param>
        </member>
        <member name="T:Griffin.Logging.Loggers.SystemDebugLogger">
            <summary>
            Logs to the debug window in Visual Studio
            </summary>
        </member>
        <member name="M:Griffin.Logging.Loggers.SystemDebugLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Logging.Loggers.SystemDebugLogger"/> class.
            </summary>
            <param name="typeThatLogs">Type of the class which uses this log. The type is used to write in the log file where the lines come from.</param>
        </member>
        <member name="M:Griffin.Logging.Loggers.SystemDebugLogger.GetStackFrame">
            <summary>
            Used to get the correct frame when <see cref="P:Griffin.Logging.Loggers.SystemDebugLogger.UseStackFrame"/> is set to true.
            </summary>
            <returns></returns>
            <remarks>
            <para>Will traverse all frames in the stack the first time this method is called. Will only get the correct frame all other times.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Logging.Loggers.SystemDebugLogger.UseStackFrame">
            <summary>
            Specifies if we should use stack frame to identify the caller (instead of <c>loggedType</c>)
            </summary>
            <remarks>
            <para>Do note that there is a performance hit by using this class.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Logging.LogLevel">
            <summary>
            Log levels
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Trace">
            <summary>
            Very detailed logs used during diagnostics
            </summary>
            <remarks>
            Should not be used other when trying to find hard-to-locate errors. You can disable trace output by using a <see cref="T:Griffin.Logging.ILogEntryFilter"/>.
            </remarks>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Debug">
            <summary>
            Diagnostics (like executing a SQL query)
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Info">
            <summary>
            Events and similar (for instance that a user have logged in)
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Warning">
            <summary>
            Something failed, but processing can continue. 
            </summary>
        </member>
        <member name="F:Griffin.Logging.LogLevel.Error">
            <summary>
            Something failed, expected execution path can not succeed.
            </summary>
        </member>
        <member name="T:Griffin.Logging.LogManager">
            <summary>
                Logging facade
            </summary>
            <remarks>
                <para>
                    Implement a <see cref="T:Griffin.Logging.ILogProvider"/> and assign it using the property <see cref="P:Griffin.Logging.LogManager.Provider"/>. You can also
                    use the default one named <see cref="T:Griffin.Logging.Providers.LogProvider"/>.
                </para>
                <para>The default behavior is to not log at all.</para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.LogManager.GetLogger``1">
            <summary>
                Get a logger
            </summary>
            <typeparam name="T">Type requesting a logger</typeparam>
            <returns>A logger</returns>
        </member>
        <member name="M:Griffin.Logging.LogManager.GetLogger(System.Type)">
            <summary>
                Get a logger
            </summary>
            <param name="typeThatWantsToLog">Type that will log messages</param>
            <returns>A logger</returns>
        </member>
        <member name="P:Griffin.Logging.LogManager.Provider">
            <summary>
                Get the current adapter
            </summary>
        </member>
        <member name="T:Griffin.Logging.NamespaceDoc">
            <summary>
                A simple logging layer which can be used to log entries to whatever you want.
            </summary>
            <remarks>
                <para>
                    To get started you should create a <see cref="T:Griffin.Logging.Providers.LogProvider"/> and assign loggers to it. Finally assign it to
                    the <see cref="P:Griffin.Logging.LogManager.Provider"/> to finish initialization.
                </para>
                <para>Now you can use the <c>GetLogger()</c> methods in your classes to access loggers.</para>
            </remarks>
            <example>
                <para>To setup the logging library:</para>
                <code>
            <![CDATA[
            var consoleLogger = new ConsoleLogger() { Filter = new OnlyExceptions() };
            var systemDebugLogger = new SystemDebugLogger() { Filter = LogLevelFilter { MinLevel = LogLevel.Info } };
            var logProvider = new LogProvider();
            logProvider.Add(consoleLogger);
            logProvider.Add(systemDebugLogger, new NamespaceFilter("MyApp.Core"));
            
            LogManager.Provider = logProvider;
            ]]>
            </code>
                <para>And to use it:</para>
                <code>
            <![CDATA[
            public class YourClass
            {
                ILogger _logger = LogManager.GetLogger<YourClass>();
            
                public void SomeMethod()
                {
                    _logger.Info("Hello {0}", "world");
                }
            }
            ]]>
            </code>
            </example>
        </member>
        <member name="T:Griffin.Logging.Providers.LogProvider">
            <summary>
                Default implementation of a log factory.
            </summary>
            <remarks>
                <para>
                    The first matching logger is the one that will be returned when a logger is requested. So add the most
                    restrictive logger first (if the first logger is not using any filter it will be returned every time).
                </para>
            </remarks>
            <example>
                <code>
            var factory = new LogFactory();
            factory.Add(new NamespaceFilter("Griffin", true), type => new ConsoleLogger(type));
            LogManager.Factory = factory;
            </code>
            </example>
        </member>
        <member name="M:Griffin.Logging.Providers.LogProvider.GetLogger(System.Type)">
            <summary>
                Creates the specified type.
            </summary>
            <param name="type">The type.</param>
            <returns>Logger to use (or <see cref="F:Griffin.Logging.Loggers.NullLogger.Instance"/> if none is found)</returns>
            <exception cref="T:System.ArgumentNullException">type</exception>
        </member>
        <member name="M:Griffin.Logging.Providers.LogProvider.Add(Griffin.Logging.ILogger)">
            <summary>
                Add a logger
            </summary>
            <param name="logger">Add a logger (will be used for all classes that want to log)</param>
            <remarks>
                <para>
                    If you want to limit which classes a logger should be able to handle you need to use the other overload:
                    <see cref="M:Griffin.Logging.Providers.LogProvider.Add(Griffin.Logging.ILogger,Griffin.Logging.ILoggerFilter)"/>
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Providers.LogProvider.Add(Griffin.Logging.ILogger,Griffin.Logging.ILoggerFilter)">
            <summary>
                Add a logger and limit which classes that can log to it.
            </summary>
            <param name="logger">Logger to use.</param>
            <param name="filter">Filter that logging types must pass.</param>
        </member>
        <member name="T:Griffin.Logging.Providers.NamespaceDoc">
            <summary>
            Classes which are used to deliver logs to the facade.
            </summary>
            <example>
            <code>
            // Create loggers
            var consoleLogger = new ConsoleLogger() { Filter = new OnlyExceptions() };
            var systemDebugLogger = new SystemDebugLogger() { Filter = LogLevelFilter { MinLevel = LogLevel.Info } };
            
            // Create the provider
            var logProvider = new LogProvider();
            logProvider.Add(consoleLogger);
            
            // can filter on namespaces.
            logProvider.Add(systemDebugLogger, new NamespaceFilter("MyApp.Core"));
            </code>
            </example>
        </member>
        <member name="T:Griffin.Logging.Providers.NamespaceFilter">
            <summary>
                Allows user to filter on certain namespaces.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Providers.NamespaceFilter"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.#ctor(System.String,System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Logging.Providers.NamespaceFilter"/> class.
            </summary>
            <param name="allowedIncludingChildNamespaces">A namespace to allow, <c>null</c> = do not add.</param>
            <param name="revokedIncludingChildNamespaces">A namespace to revoke, <c>null</c> = do not add.</param>
            <remarks>
                Constructor can be used to get less bootstrapping code.
            </remarks>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.IsSatisfiedBy(System.Type)">
            <summary>
                Checks if the specified logger may log to a certain logger.
            </summary>
            <param name="typeThatWantToLog">Type that want's to write to a log.</param>
            <returns>
                <c>true</c> if the logging type is acceptable by this filter; otherwise <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentNullException">typeThatWantToLog</exception>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.Allow(System.String,System.Boolean)">
            <summary>
                Allows the specified the namespace.
            </summary>
            <param name="theNamespace">The namespace to allow.</param>
            <param name="allowChildNamespaces">if set to <c>true</c> all child namespaces is also allowed.</param>
            <exception cref="T:System.ArgumentNullException">theNamespace</exception>
        </member>
        <member name="M:Griffin.Logging.Providers.NamespaceFilter.Revoke(System.String,System.Boolean)">
            <summary>
                Revokes the specified the namespace.
            </summary>
            <param name="theNamespace">The namespace.</param>
            <param name="includeChildNamespaces">if set to <c>true</c> all child namespaces is also revoked.</param>
            <exception cref="T:System.ArgumentNullException">theNamespace</exception>
        </member>
        <member name="T:Griffin.Logging.Providers.NoFilter">
            <summary>
            Disable filtering.
            </summary>
        </member>
        <member name="F:Griffin.Logging.Providers.NoFilter.Instance">
            <summary>
                Instance to use
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NoFilter.#ctor">
            <summary>
                Prevents a default instance of the <see cref="T:Griffin.Logging.Providers.NoFilter"/> class from being created.
            </summary>
        </member>
        <member name="M:Griffin.Logging.Providers.NoFilter.IsSatisfiedBy(System.Type)">
            <summary>
            Will always return true
            </summary>
            <param name="typeThatWantToLog">Type that wants to get a logger to be able to log entries that have been written by the dev.</param>
            <returns>Always <c>true</c>. <c>true</c>.</returns>
        </member>
        <member name="T:Griffin.Logging.Providers.NullLogProvider">
            <summary>
            Just returns <see cref="F:Griffin.Logging.Loggers.NullLogger.Instance"/> for every request.
            </summary>
        </member>
        <member name="T:Griffin.Net.ChannelTcpClient`1">
            <summary>
            Can talk with messaging servers (i.e. servers based on <see cref="T:Griffin.Net.ChannelTcpListener"/>).
            </summary>
            <typeparam name="T">Type of message to receive</typeparam>
        </member>
        <member name="M:Griffin.Net.ChannelTcpClient`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="T:Griffin.Net.Buffers.BufferSlice">
            <summary>
                Used to slice a larger buffer into smaller chunks.
            </summary>
        </member>
        <member name="T:Griffin.Net.Buffers.IBufferSlice">
            <summary>
            A slice of a larger buffer
            </summary>
            <remarks>
            <para>
            
            To reduce the amount of allocations we can allocate a large buffer and then slice it into smaller chunks. This interface represents a chunk.
            
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Buffers.IBufferSlice.Offset">
            <summary>
            Where this slice starts
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.IBufferSlice.Capacity">
            <summary>
            Amount of bytes allocated for this slice
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.IBufferSlice.Buffer">
            <summary>
            Buffer that this is a slice of.
            </summary>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlice.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Buffers.BufferSlice"/> class.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">Start offset in buffer.</param>
            <param name="count">Number of bytes allocated for this slice..</param>
            <exception cref="T:System.ArgumentNullException">buffer</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset;Offset+Count must be less than the buffer length.</exception>
        </member>
        <member name="P:Griffin.Net.Buffers.BufferSlice.Offset">
            <summary>
                Where this slice starts
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.BufferSlice.Capacity">
            <summary>
                AMount of bytes allocated for this slice.
            </summary>
        </member>
        <member name="P:Griffin.Net.Buffers.BufferSlice.Buffer">
            <summary>
                Buffer that this slice is in.
            </summary>
        </member>
        <member name="T:Griffin.Net.Buffers.BufferSlicePool">
            <summary>
            Creates a large buffer and slices it.
            </summary>
            <remarks>
            <para>
            Thread safe, can be used to reuse slices.
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlicePool.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Buffers.BufferSlicePool"/> class.
            </summary>
            <param name="sliceSize">How large each slice should be.</param>
            <param name="numberOfBuffers">The number of slices.</param>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlicePool.Pop">
            <summary>
            Get a new slice
            </summary>
            <returns>Slice</returns>
            <exception cref="T:Griffin.Net.Buffers.PoolEmptyException">Out of buffers. You are either not releasing used buffers or have allocated less number of buffers than allowed number of connected clients.</exception>
        </member>
        <member name="M:Griffin.Net.Buffers.BufferSlicePool.Push(Griffin.Net.Buffers.IBufferSlice)">
            <summary>
            Enqueue a slice to be able to re-use it later
            </summary>
            <param name="bufferSlice">Slice to append</param>
            <exception cref="T:System.ArgumentNullException">bufferSlice</exception>
        </member>
        <member name="T:Griffin.Net.Buffers.PoolEmptyException">
            <summary>
                A object pool (or similar) have no more items to give out.
            </summary>
            <remarks>This exception typically occurrs if the pool/stack is too small (too many concurrent operations) or if some code fail to return the item to the pool when done.</remarks>
        </member>
        <member name="M:Griffin.Net.Buffers.PoolEmptyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Buffers.PoolEmptyException"/> class.
            </summary>
            <param name="errorMessage">The error message.</param>
        </member>
        <member name="T:Griffin.Net.Channels.ChannelData">
            <summary>
            Uses a concurrent dictionary to store all itemns.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.IChannelData">
            <summary>
            Used to store data in a connected channel.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.IChannelData.GetOrAdd(System.String,System.Func{System.String,System.Object})">
            <summary>
            Get or add a value
            </summary>
            <param name="key">key to geet</param>
            <param name="addCallback">Should return value to add if the key is not found</param>
        </member>
        <member name="M:Griffin.Net.Channels.IChannelData.TryUpdate(System.String,System.Object,System.Object)">
            <summary>
            Try updating a value
            </summary>
            <param name="key">Key for the value to update</param>
            <param name="newValue">Value to set</param>
            <param name="existingValue">Value that we've previously retreived</param>
            <returns><c>true</c> if the existing value is the same as the one in the dictionary</returns>
        </member>
        <member name="M:Griffin.Net.Channels.IChannelData.Clear">
            <summary>
            Remove all existing data.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.IChannelData.Item(System.String)">
            <summary>
            Get or set data
            </summary>
            <param name="key">Identifier (note that everyone with access to the channel can access the data, use careful naming)</param>
            <returns>Data if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ChannelData.TryUpdate(System.String,System.Object,System.Object)">
            <summary>
            Try updating a value
            </summary>
            <param name="key">Key for the value to update</param>
            <param name="newValue">Value to set</param>
            <param name="existingValue">Value that we've previously retreived</param>
            <returns><c>true</c> if the existing value is the same as the one in the dictionary</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ChannelData.Clear">
            <summary>
            Remove all existing data.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ChannelData.Item(System.String)">
            <summary>
            Get or set data
            </summary>
            <param name="key">Identifier (note that everyone with access to the channel can access the data, use careful naming)</param>
            <returns>Data if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Channels.ClientCertificate">
            <summary>
            Client X.509 certificate, X.509 chain, and any SSL policy errors encountered
            during the SSL stream creation
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ClientCertificate.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Channels.ClientCertificate"/> class.
            </summary>
            <param name="certificate">The certificate.</param>
            <param name="chain">Client security certificate chain.</param>
            <param name="sslPolicyErrors">Any SSL policy errors encountered during the SSL stream creation.</param>
            <exception cref="T:System.ArgumentNullException">
            certificate
            or
            chain
            </exception>
        </member>
        <member name="P:Griffin.Net.Channels.ClientCertificate.Certificate">
            <summary>
            Client security certificate
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientCertificate.Chain">
            <summary>
            Client security certificate chain
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientCertificate.SslPolicyErrors">
            <summary>
            Any SSL policy errors encountered during the SSL stream creation
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ClientSideSslStreamBuilder">
            <summary>
            Builder used to create SslStreams for client side applications.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ISslStreamBuilder">
            <summary>
            Used to build SSL streams (i.e. create and do the initial handshake)
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ISslStreamBuilder.Build(Griffin.Net.Channels.ITcpChannel,System.Net.Sockets.Socket)">
            <summary>
            Build a new SSL steam.
            </summary>
            <param name="channel">Channel which will use the stream</param>
            <param name="socket">Socket to wrap</param>
            <returns>Stream which is ready to be used (must have been validated)</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ClientSideSslStreamBuilder.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="commonName">the domain name of the server that you are connecting to</param>
        </member>
        <member name="M:Griffin.Net.Channels.ClientSideSslStreamBuilder.Build(Griffin.Net.Channels.ITcpChannel,System.Net.Sockets.Socket)">
            <summary>
            Build a new SSL steam.
            </summary>
            <param name="channel">Channel which will use the stream</param>
            <param name="socket">Socket to wrap</param>
            <returns>Stream which is ready to be used (must have been validated)</returns>
        </member>
        <member name="P:Griffin.Net.Channels.ClientSideSslStreamBuilder.CommonName">
            <summary>
            Typically the domain name of the server that you are connecting to.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientSideSslStreamBuilder.Certificate">
            <summary>
            Leave empty to use the server certificate
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ClientSideSslStreamBuilder.Protocols">
            <summary>
            Allowed SSL protocols
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.ChannelFailureHandler">
            <summary>
            Invoked by <see cref="T:Griffin.Net.Channels.ITcpChannel"/> if the <see cref="T:Griffin.Net.IMessageDecoder"/> failes to parse incoming message.
            </summary>
            <param name="channel">Channel that the decoder belongs to</param>
            <param name="error">Why the decoder failed</param>
            <remarks>
            <para>
            Typically the handler will send an error message and close the connection.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Channels.DisconnectHandler">
            <summary>
            <see cref="T:Griffin.Net.Channels.ITcpChannel"/> got disconnected
            </summary>
            <param name="channel">Channel which got disconnected</param>
            <param name="exception">Exception  (<c>SocketException</c> for TCP errors)</param>
            <seealso cref="T:Griffin.Net.Channels.ITcpChannel"/>
        </member>
        <member name="T:Griffin.Net.Channels.EmptyEndpoint">
            <summary>
            Used when there are no connected endpoint for a channel
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.EmptyEndpoint.ToString">
            <summary>
                Returns "None"
            </summary>
            <returns>
                A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Channels.EmptyEndpoint.AddressFamily">
            <summary>
                Gets the address family to which the endpoint belongs.
            </summary>
            <returns>
                <c>AddressFamily.Unspecified</c>
            </returns>
            <exception cref="T:System.NotImplementedException">
                Any attempt is made to get or set the property when the property is
                not overridden in a descendant class.
            </exception>
            <PermissionSet>
                <IPermission
                    class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"
                    version="1" Flags="UnmanagedCode, ControlEvidence" />
            </PermissionSet>
        </member>
        <member name="T:Griffin.Net.Channels.ISocketBuffer">
            <summary>
                Used to wrap <c>SocketAsyncEventArgs</c> to make everything testable (which <c>SocketAsyncEventArgs</c> isn't due
                to private setters and socket references).
            </summary>
            <seealso cref="T:Griffin.Net.Channels.SocketAsyncEventArgsWrapper"/>
        </member>
        <member name="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)">
            <summary>
                Reuse the previously specified buffer, but change the offset/count of the bytes to send.
            </summary>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Amount of bytes to send</param>
        </member>
        <member name="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
                Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Amount of bytes to send</param>
            <param name="capacity">Total number of bytes allocated for this slices</param>
        </member>
        <member name="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Amount of bytes to send</param>
            <remarks>Capacity will be set to same as <c>count</c>.</remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.UserToken">
            <summary>
                an object which can be used by you to keep track of what's being sent and received.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.BytesTransferred">
            <summary>
                Number of bytes which was received or transmitted in the last Socket operation
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Count">
            <summary>
                Amount of bytes to receive or send in the next Socket operation.
            </summary>
            <seealso cref="P:Griffin.Net.Channels.ISocketBuffer.Offset"/>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Capacity">
            <summary>
                Amount of bytes allocated for this buffer
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Buffer">
            <summary>
                Buffer used for transfers
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.BaseOffset">
            <summary>
                Offset in buffer were our allocated part starts
            </summary>
            <remarks>A buffer can have been divided between many channels. this index tells us where our slice starts.</remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ISocketBuffer.Offset">
            <summary>
                Start offset for the next socket operation. (Typically same as BaseOffset unless this is a continuation of a
                partial message send).
            </summary>
            <seeAlso cref="P:Griffin.Net.Channels.ISocketBuffer.Count"/>
        </member>
        <member name="T:Griffin.Net.Channels.ITcpChannel">
            <summary>
                A channel is used to send and receive information over a socket.
            </summary>
            <remarks>
                <para>
                    Channels should be designed so that they can be reused after a client have disconnected. Hence you have sure
                    that the state is cleared when the <c>Cleanup()</c> method is invoked. Buffers etc should still be used,
                    but any internal send queue etc should be emptied.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Assign(System.Net.Sockets.Socket)">
            <summary>
                Assign a socket to this channel
            </summary>
            <param name="socket">Connected socket</param>
            <remarks>
                the channel will start receive new messages as soon as you've called assign.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Cleanup">
            <summary>
                Cleanup everything so that the channel can be reused.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Send(System.Object)">
            <summary>
                Send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                <para>
                    Outbound messages are enqueued and sent in order.
                </para>
                <para>
                    You may enqueue <c>byte[]</c> arrays or <see cref="T:System.IO.Stream"/>  objects. They will not be serialized but
                    MicroMessage framed directly.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannel.Close">
            <summary>
            Close channel
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.Disconnected">
            <summary>
                Channel got disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.MessageReceived">
            <summary>
                Channel received a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.MessageSent">
            <summary>
                Channel have sent a message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.ChannelFailure">
            <summary>
            Invoked if the decoder failes to handle an incoming message
            </summary>
            <remarks>
            <para>
            The handler MUST close the connection once a reply have been sent.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.RemoteEndpoint">
            <summary>
                Gets address of the connected end point.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.ChannelId">
            <summary>
            Identity of this channel
            </summary>
            <remarks>
            Must be unique within a server.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannel.Data">
            <summary>
            Can be used to store information in the channel so that you can access it at later requests.
            </summary>
            <remarks>
            <para>All data is lost when the channel is closed.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Channels.MessageHandler">
            <summary>
            <see cref="T:Griffin.Net.Channels.ITcpChannel"/> have sent or received a message.
            </summary>
            <param name="channel">Channel that did the work</param>
            <param name="message">Message. depends on which encoder/decoder was used.</param>
            <remarks>We uses delegates instead of regular events to make sure that there are only one subscriber and that it's configured once.</remarks>
        </member>
        <member name="T:Griffin.Net.Channels.SecureTcpChannel">
            <summary>
            Used to secure the transport.
            </summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.#ctor(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.Protocols.IMessageEncoder,Griffin.Net.IMessageDecoder,Griffin.Net.Channels.ISslStreamBuilder)">
            <summary>
            
            </summary>
            <param name="readBuffer"></param>
            <param name="encoder"></param>
            <param name="decoder"></param>
            <param name="sslStreamBuilder">Used to wrap the socket with a SSL stream</param>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Assign(System.Net.Sockets.Socket)">
            <summary>
                Assign a socket to this channel
            </summary>
            <param name="socket">Connected socket</param>
            <remarks>
                the channel will start receive new messages as soon as you've called assign.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Send(System.Object)">
            <summary>
                Send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                <para>
                    Outbound messages are enqueued and sent in order.
                </para>
                <para>
                    You may enqueue <c>byte[]</c> arrays or <see cref="T:System.IO.Stream"/>  objects. They will not be serialized but
                    MicroMessage framed directly.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Close">
            <summary>
            Close channel, wait for all messages to be sent.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.CloseAsync">
            <summary>
                Signal channel to close.
            </summary>
            <remarks>
                <para>
                    Will wait for all data to be sent before closing.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannel.Cleanup">
            <summary>
                Cleanup everything so that the channel can be resused.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.Disconnected">
            <summary>
                Channel got disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.MessageReceived">
            <summary>
                Channel received a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.MessageSent">
            <summary>
                Channel have sent a message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.ChannelFailure">
            <summary>
            Invoked if the decoder failes to handle an incoming message
            </summary>
            <remarks>
            <para>
            The handler MUST close the connection once a reply have been sent.
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.RemoteEndpoint">
            <summary>
                Gets address of the connected end point.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.ChannelId">
            <summary>
            Identity of this channel
            </summary>
            <remarks>
            Must be unique within a server.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannel.Data">
            <summary>
            Can be used to store information in the channel so that you can access it at later requests.
            </summary>
            <remarks>
            <para>All data is lost when the channel is closed.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Channels.ServerSideSslStreamBuilder">
            <summary>
            Used to build SSL streams for server side applications.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.ServerSideSslStreamBuilder.Build(Griffin.Net.Channels.ITcpChannel,System.Net.Sockets.Socket)">
            <summary>
            Build a new SSL steam.
            </summary>
            <param name="channel">Channel which will use the stream</param>
            <param name="socket">Socket to wrap</param>
            <returns>Stream which is ready to be used (must have been validated)</returns>
        </member>
        <member name="M:Griffin.Net.Channels.ServerSideSslStreamBuilder.OnRemoteCertifiateValidation(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
            <summary>
            Works just like the <a href="http://msdn.microsoft.com/en-us/library/system.net.security.remotecertificatevalidationcallback(v=vs.110).aspx">callback</a> for <c>SslStream</c>
            </summary>
            <param name="sender"></param>
            <param name="certificate"></param>
            <param name="chain"></param>
            <param name="sslpolicyerrors"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.CheckCertificateRevocation">
            <summary>
            check if the certificate have been revoked.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.Protocols">
            <summary>
            Allowed protocols
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.UseClientCertificate">
            <summary>
            The client must supply a certificate
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.ServerSideSslStreamBuilder.Certificate">
            <summary>
            Certificate to use in this server.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.SocketAsyncEventArgsWrapper">
            <summary>
            The real implementation which uses <c>SocketAsyncEventArgs</c> internally.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.#ctor(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Channels.SocketAsyncEventArgsWrapper"/> class.
            </summary>
            <param name="args">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/> instance containing the event data.</param>
            <exception cref="T:System.ArgumentNullException">args</exception>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.SetBuffer(System.Int32,System.Int32)">
            <summary>
            Set the bytes which currently should be transferred in the next I/O operation (or the bytes which was just received)
            </summary>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.SetBuffer(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Amount of bytes to send</param>
            <param name="capacity">Total number of bytes allocated for this slices</param>
        </member>
        <member name="M:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.SetBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Assign a buffer to the structure
            </summary>
            <param name="buffer">Buffer to use</param>
            <param name="offset">Index of first byte to send</param>
            <param name="count">Amount of bytes to send</param>
            <remarks>
            Capacity will be set to same as <c>count</c>.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.UserToken">
            <summary>
                an object which can be used by you to keep track of what's being sent and received.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.BytesTransferred">
            <summary>
            Amount of bytes which was transferred in the last I/O operation
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Count">
            <summary>
            Amount of bytes in our buffer.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Capacity">
            <summary>
            Amount of bytes which we can use in the buffer.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Buffer">
            <summary>
            Buffer to use (or rather a slice of it)
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.BaseOffset">
            <summary>
            Where our slice starts in the <see cref="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Buffer"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketAsyncEventArgsWrapper.Offset">
            <summary>
            Current offset in the buffer.
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.SocketBuffer">
            <summary>
                USed for the SecureTcpChannel as we can't use the Async socket methods with it :(
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.SocketBuffer.UserToken">
            <summary>
                an object which can be used by you to keep track of what's being sent and received.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.#ctor(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.Protocols.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Channels.TcpChannel"/> class.
            </summary>
            <param name="readBuffer">Buffer used for our reading.</param>
            <param name="encoder">Used to encode messages before they are put in the MicroMessage body of outbound messages.</param>
            <param name="decoder">
                Used to decode the body of incoming MicroMessages. The <c>MessageReceived</c> delegate will be
                overriden by this class.
            </param>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Assign(System.Net.Sockets.Socket)">
            <summary>
                Assign a socket to this channel
            </summary>
            <param name="socket">Connected socket</param>
            <remarks>
                the channel will start receive new messages as soon as you've called assign.
                <para>
                    You must have specified a <see cref="P:Griffin.Net.Channels.TcpChannel.MessageReceived"/> delegate first.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Send(System.Object)">
            <summary>
                Send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                <para>
                    Outbound messages are enqueued and sent in order.
                </para>
                <para>
                    You may enqueue <c>byte[]</c> arrays or <see cref="T:System.IO.Stream"/>  objects. They will not be serialized but
                    MicroMessage framed directly.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Close">
            <summary>
                Signal channel to close.
            </summary>
            <remarks>
                <para>
                    Will wait for all data to be sent before closing.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.Cleanup">
            <summary>
                Cleanup everything so that the channel can be resused.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.CloseAsync">
            <summary>
                Signal channel to close.
            </summary>
            <remarks>
                <para>
                    Will wait for all data to be sent before closing.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannel.HandleDisconnect(System.Net.Sockets.SocketError)">
            <summary>
            </summary>
            <param name="socketError">ProtocolNotSupported = decoder failure.</param>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.Disconnected">
            <summary>
                Channel got disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.OutboundMessageQueue">
            <summary>
            Used to enqueue outbound messages (to support asynchronous handling, i.e. enqueue more messages before the current one have been sent)
            </summary>
            <remarks>
            <para>
            This property exists so that you can switch implementation.  This is used by the HttpListener so that we can add support
            for message pipelininig
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.MessageReceived">
            <summary>
                Channel received a new message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.MessageSent">
            <summary>
                Channel have sent a message
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.ChannelFailure">
            <summary>
                The channel failed to complete an IO operation
            </summary>
            <remarks>
                <para>
                    The handler MUST close the connection once a reply have been sent.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.RemoteEndpoint">
            <summary>
                Gets address of the connected end point.
            </summary>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.ChannelId">
            <summary>
                Identity of this channel
            </summary>
            <remarks>
                Must be unique within a server.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannel.Data">
            <summary>
                Can be used to store information in the channel so that you can access it at later requests.
            </summary>
            <remarks>
                <para>All data is lost when the channel is closed.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.ChannelTcpListener">
            <summary>
                Listens on one of the specified protocols
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.IMessagingListener">
            <summary>
            Used to listen on new messages
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessagingListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener
            </summary>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.ChannelTcpListener.LocalPort"/>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessagingListener.Stop">
            <summary>
            Stop the listener.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.IMessagingListener.ChannelFactory">
            <summary>
                Used to create channels. Default is <see cref="T:Griffin.Net.Channels.TcpChannelFactory"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.IMessagingListener.MessageReceived">
            <summary>
                Delegate invoked when a new message is received
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.IMessagingListener.MessageSent">
            <summary>
                Delegate invoked when a message have been sent to the remote end point
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.IMessagingListener.ClientConnected">
            <summary>
                A client have connected (nothing have been sent or received yet)
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.IMessagingListener.ClientDisconnected">
            <summary>
                A client have disconnected
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener
            </summary>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.ChannelTcpListener.LocalPort"/>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.Stop">
            <summary>
                Stop the listener.
            </summary>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.Configure(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
                To allow the sub classes to configure this class in their constructors.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.OnClientConnected(Griffin.Net.Channels.ITcpChannel)">
            <summary>
                A client have connected (nothing have been sent or received yet)
            </summary>
            <param name="channel">Channel which we created for the remote socket.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.OnClientDisconnected(Griffin.Net.Channels.ITcpChannel,System.Exception)">
            <summary>
                A client have disconnected
            </summary>
            <param name="channel">Channel representing the client that disconnected</param>
            <param name="exception">
                Exception which was used to detect disconnect (<c>SocketException</c> with status
                <c>Success</c> is created for graceful disconnects)
            </param>
        </member>
        <member name="M:Griffin.Net.ChannelTcpListener.OnMessage(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
                Receive a new message from the specified client
            </summary>
            <param name="source">Channel for the client</param>
            <param name="msg">Message (as decoded by the specified <see cref="T:Griffin.Net.IMessageDecoder"/>).</param>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.LocalPort">
            <summary>
                Port that the server is listening on.
            </summary>
            <remarks>
                You can use port <c>0</c> in <see cref="M:Griffin.Net.ChannelTcpListener.Start(System.Net.IPAddress,System.Int32)"/> to let the OS assign a port. This method will then give you the
                assigned port.
            </remarks>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.ChannelFactory">
            <summary>
                Used to create channels. Default is <see cref="T:Griffin.Net.Channels.TcpChannelFactory"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.MessageReceived">
            <summary>
                Delegate invoked when a new message is received
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListener.MessageSent">
            <summary>
                Delegate invoked when a message have been sent to the remote end point
            </summary>
        </member>
        <member name="E:Griffin.Net.ChannelTcpListener.ClientConnected">
            <summary>
                A client have connected (nothing have been sent or received yet)
            </summary>
        </member>
        <member name="E:Griffin.Net.ChannelTcpListener.ClientDisconnected">
            <summary>
                A client have disconnected
            </summary>
        </member>
        <member name="E:Griffin.Net.ChannelTcpListener.ListenerError">
            <summary>
                An internal error occured
            </summary>
        </member>
        <member name="T:Griffin.Net.ChannelTcpListenerConfiguration">
            <summary>
            Configuration for <see cref="T:Griffin.Net.ChannelTcpListener"/>
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListenerConfiguration.DecoderFactory">
            <summary>
            Factory used to produce a decoder for every connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListenerConfiguration.EncoderFactory">
            <summary>
            Factory used to produce an encoder for every connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.ChannelTcpListenerConfiguration.BufferPool">
            <summary>
            Pool used to allocate buffers for every client
            </summary>
            <remarks>
            Each client requires one buffer (for receiving).
            </remarks>
            <value>
            100 buffers of size 65535 bytes are allocated per default.
            </value>
        </member>
        <member name="T:Griffin.Net.IMessageQueue">
            <summary>
                Used to enqueue outbound messages
            </summary>
            <remarks>
                <para>
                    As a socket must complete it's operations before the next message can be send we need to be able to queue
                    outbound messages
                    so that we have a chance to complete IO operations for each message.
                </para>
                <para>
                    Without this, the socket would probably throw errors on us due toe the asynchronous nature of this library
                    implementation
                </para>
                <para>
                    You can create your own implementation which could allow for prioritizing or so that messages are sent in the
                    same order as their corresponding request comes in (if the message processors are not completed in order)
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.IMessageQueue.Enqueue(System.Object)">
            <summary>
                Enqueue a message
            </summary>
            <param name="message">message to enqueue</param>
            <remarks>
                <para>
                    Messages do not have to be placed in order, place them as they should be sent out.
                </para>
                <para>
                    You must be able to enqueue all messages as the library use some internal messages for different operations
                    (like being able to close when all messages have been sent)
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.IMessageQueue.TryDequeue(System.Object@)">
            <summary>
                Get the next message that should be sent
            </summary>
            <param name="msg">Message to send</param>
            <returns><c>true</c> if there was a message to send.</returns>
        </member>
        <member name="T:Griffin.Net.MessageQueue">
            <summary>
                Used to enqueue outbound messages
            </summary>
            <remarks>
                <para>
                    Implemented using a ConcurrentQueue.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.MessageQueue.Enqueue(System.Object)">
            <summary>
                Enqueue a message
            </summary>
            <param name="message">message to enqueue</param>
            <remarks>
                <para>
                    Messages do not have to be placed in order, place them as they should be sent out.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.MessageQueue.TryDequeue(System.Object@)">
            <summary>
                Get the next message that should be sent
            </summary>
            <param name="msg">Message to send</param>
            <returns><c>true</c> if there was a message to send.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.ClientConnectedEventArgs">
            <summary>
                Used by <see cref="E:Griffin.Net.ChannelTcpListener.ClientConnected"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientConnectedEventArgs.#ctor(Griffin.Net.Channels.ITcpChannel)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.ClientConnectedEventArgs"/> class.
            </summary>
            <param name="channel">The channel.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientConnectedEventArgs.CancelConnection">
            <summary>
                Cancel connection, will make the listener close it.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientConnectedEventArgs.CancelConnection(System.IO.Stream)">
            <summary>
                Close the listener, but send a response (you are yourself responsible of encoding it to a message)
            </summary>
            <param name="response">Stream with encoded message (which can be sent as-is).</param>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.Channel">
            <summary>
                Channel for the connected client
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.Response">
            <summary>
                Response (if the client may not connect)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientConnectedEventArgs.MayConnect">
            <summary>
                Determines if the client may connect.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.ClientDisconnectedEventArgs">
            <summary>
                Event arguments for <see cref="E:Griffin.Net.ChannelTcpListener.ClientDisconnected"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ClientDisconnectedEventArgs.#ctor(Griffin.Net.Channels.ITcpChannel,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.ClientDisconnectedEventArgs"/> class.
            </summary>
            <param name="channel">The channel that disconnected.</param>
            <param name="exception">The exception that was caught.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientDisconnectedEventArgs.Channel">
            <summary>
            Channel that was disconnected
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ClientDisconnectedEventArgs.Exception">
            <summary>
            Exception that was caught (is SocketException if the connection failed or if the remote end point disconnected).
            </summary>
            <remarks>
            <c>SocketException</c> with status <c>Success</c> is created for graceful disconnects.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication">
            <summary>
                Authenticates using a HTTP cookie
            </summary>
            <remarks>
                <para>
                    Do note that this implementation hashes the user IP address. That means that the cookie is not valid if the
                    user gets a new IP. This is done
                    to prevent cookie hijacking.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IAuthenticator">
            <summary>
            Used to authenticate the user.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAuthenticator.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAuthenticator.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>UserName if successful; otherwise null.</returns>
            <exception cref="T:Griffin.Net.Protocols.Http.HttpException">403 Forbidden if the nonce is incorrect.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticator.AuthenticationScheme">
            <summary>
            Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.#ctor(System.String)">
            <summary>
            </summary>
            <param name="hashKey">Used to hash the ip address, recommended size is 64 bytes.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
                Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
                Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>UserName if successful; otherwise null.</returns>
            <exception cref="T:Griffin.Net.Protocols.Http.HttpException">403 Forbidden if the nonce is incorrect.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.CookieName">
            <summary>
                Name of the  authenticationCookie
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.HashKey">
            <summary>
                Can be any length, but 64 bytes is recommended.
            </summary>
            <remarks>
                Used to hash the machine identity
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.CookieAuthentication.AuthenticationScheme">
            <summary>
                Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentPriorityQueue`2">
            <summary>Provides a thread-safe priority queue data structure.</summary>
            <typeparam name="TKey">Specifies the type of keys used to prioritize values.</typeparam>
            <typeparam name="TValue">Specifies the type of elements in the queue.</typeparam>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.#ctor">
            <summary>Initializes a new instance of the ConcurrentPriorityQueue class.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>Initializes a new instance of the ConcurrentPriorityQueue class that contains elements copied from the specified collection.</summary>
            <param name="collection">The collection whose elements are copied to the new ConcurrentPriorityQueue.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.Enqueue(`0,`1)">
            <summary>Adds the key/value pair to the priority queue.</summary>
            <param name="priority">The priority of the item to be added.</param>
            <param name="value">The item to be added.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.Enqueue(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Adds the key/value pair to the priority queue.</summary>
            <param name="item">The key/value pair to be added to the queue.</param>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.TryDequeue(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Attempts to remove and return the next prioritized item in the queue.</summary>
            <param name="result">
            When this method returns, if the operation was successful, result contains the object removed. If
            no object was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the queue succesfully; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.TryPeek(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Attempts to return the next prioritized item in the queue.</summary>
            <param name="result">
            When this method returns, if the operation was successful, result contains the object.
            The queue was not modified by the operation.
            </param>
            <returns>
            true if an element was returned from the queue succesfully; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.Clear">
            <summary>Empties the queue.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>Copies the elements of the collection to an array, starting at a particular array index.</summary>
            <param name="array">
            The one-dimensional array that is the destination of the elements copied from the queue.
            </param>
            <param name="index">
            The zero-based index in array at which copying begins.
            </param>
            <remarks>The elements will not be copied to the array in any guaranteed order.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.ToArray">
            <summary>Copies the elements stored in the queue to a new array.</summary>
            <returns>A new array containing a snapshot of elements copied from the queue.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.System#Collections#Concurrent#IProducerConsumerCollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#TryAdd(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Attempts to add an item in the queue.</summary>
            <param name="item">The key/value pair to be added.</param>
            <returns>
            true if the pair was added; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.System#Collections#Concurrent#IProducerConsumerCollection{System#Collections#Generic#KeyValuePair{TKey@TValue}}#TryTake(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>Attempts to remove and return the next prioritized item in the queue.</summary>
            <param name="item">
            When this method returns, if the operation was successful, result contains the object removed. If
            no object was available to be removed, the value is unspecified.
            </param>
            <returns>
            true if an element was removed and returned from the queue succesfully; otherwise, false.
            </returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.GetEnumerator">
            <summary>Returns an enumerator that iterates through the collection.</summary>
            <returns>An enumerator for the contents of the queue.</returns>
            <remarks>
            The enumeration represents a moment-in-time snapshot of the contents of the queue. It does not
            reflect any updates to the collection after GetEnumerator was called. The enumerator is safe to
            use concurrently with reads from and writes to the queue.
            </remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through a collection.</summary>
            <returns>An IEnumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>Copies the elements of the collection to an array, starting at a particular array index.</summary>
            <param name="array">
            The one-dimensional array that is the destination of the elements copied from the queue.
            </param>
            <param name="index">
            The zero-based index in array at which copying begins.
            </param>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentPriorityQueue`2.IsEmpty">
            <summary>Gets whether the queue is empty.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentPriorityQueue`2.Count">
            <summary>Gets the number of elements contained in the queue.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentPriorityQueue`2.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the ICollection is synchronized with the SyncRoot.
            </summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentPriorityQueue`2.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the collection.
            </summary>
        </member>
        <member name="T:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap">
            <summary>Implements a binary heap that prioritizes smaller values.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.#ctor">
            <summary>Initializes an empty heap.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.#ctor(System.Collections.Concurrent.ConcurrentPriorityQueue{`0,`1}.MinBinaryHeap)">
            <summary>Initializes a heap as a copy of another heap instance.</summary>
            <param name="heapToCopy">The heap to copy.</param>
            <remarks>Key/Value values are not deep cloned.</remarks>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.Clear">
            <summary>Empties the heap.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.Insert(`0,`1)">
            <summary>Adds an item to the heap.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.Insert(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>Adds an item to the heap.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.Peek">
            <summary>Returns the entry at the top of the heap.</summary>
        </member>
        <member name="M:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.Remove">
            <summary>Removes the entry at the top of the heap.</summary>
        </member>
        <member name="P:System.Collections.Concurrent.ConcurrentPriorityQueue`2.MinBinaryHeap.Count">
            <summary>Gets the number of objects stored in the heap.</summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpCookie">
            <summary>
            Create a new HTTP cookie
            </summary>
            <remarks>Typically a request cookie, since response cookies need more information.</remarks>
            <seealso cref="T:Griffin.Net.Protocols.Http.HttpResponseCookie"/>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpCookie">
            <summary>
            A cookie
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookie.Name">
            <summary>
            Gets the cookie identifier.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookie.Value">
            <summary>
            Gets value. 
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookie.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpCookie"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookie.Name">
            <summary>
            Gets the cookie identifier.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookie.Value">
            <summary>
            Gets value. 
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpCookieCollection`1">
            <summary>
            A collection of HTTP cookies
            </summary>
            <typeparam name="T">Type of cookie</typeparam>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpCookieCollection`1">
            <summary>
            Collection of cookies
            </summary>
            <typeparam name="T">Type of cookie</typeparam>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Add(`0)">
            <summary>
            Add a cookie.
            </summary>
            <param name="cookie">Cookie to add</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Clear">
            <summary>
            Remove all cookies.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Remove(System.String)">
            <summary>
            Remove a cookie from the collection.
            </summary>
            <param name="cookieName">Name of cookie.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpCookieCollection`1.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (<c>null</c> if not existing).
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Add(`0)">
            <summary>
            Adds the specified cookie.
            </summary>
            <param name="cookie">The cookie.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Clear">
            <summary>
            Remove all cookies.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Remove(System.String)">
            <summary>
            Remove a cookie from the collection.
            </summary>
            <param name="cookieName">Name of cookie.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Count">
            <summary>
            Gets the count of cookies in the collection.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpCookieCollection`1.Item(System.String)">
            <summary>
            Gets the cookie of a given identifier (<c>null</c> if not existing).
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpRequest">
            <summary>
            A HTTP request where the included body have been parsed
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpMessage">
            <summary>
            Base class for HTTP requests and responses.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpMessage">
            <summary>
                Represents a request or resposne.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpMessage.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.StatusLine">
            <summary>
                First line in a HTTP message divided into parts (array with three items).
            </summary>
            <remarks>
                <para>The content of the line depends on if this is a HTTP request </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.HttpVersion">
            <summary>
                Version of the HTTP protocol
            </summary>
            <remarks>
                <para>
                    Typically <c>HTTP/1.1</c> but can also be the old version <c>HTTP/1.0</c> or the new draft <c>HTTP/2.0</c>
                    (aka SPDY)
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.Headers">
            <summary>
                All HTTP headers.
            </summary>
            <remarks>
                <para>Missing headers will return <c>null</c> as value</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.Body">
            <summary>
                Body in the HTTP message
            </summary>
            <remarks>
                <para>
                    The body has not been modified or parsed in any way. The actual stream is either a <c>MemoryStream</c> or
                    <c>FileStream</c> depending on the
                    size of the body.
                </para>
                <para>
                    The implementation of this interface should have the control over the specified stream. That is, the stream
                    will always be disposed by this library when the message has been processed.
                    Hence you have to make sure that we can take control over the stream that you've specified.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.ContentLength">
            <summary>
                Length of the body in bytes.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.ContentType">
            <summary>
                Content type without any parameters.
            </summary>
            <remarks>
                <para>
                    If you need to get the boundry etc, then use <c>request.Headers["Content-Type"]</c>.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpMessage.ContentCharset">
            <summary>
                The encoding used in the document (if it's text of some sort)
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.HttpMessage.PipelineIndexKey">
            <summary>
                Used to be able to send responses in the same order as the request came in (if the web browser supports request
                pipelining)
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessage.#ctor(System.String)">
            <summary>
            </summary>
            <param name="httpVersion">Version like <c>HTTP/1.1</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessage.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessage.OnHeaderSet(System.String,System.String)">
            <summary>
                Invoked every time a HTTP header is modified.
            </summary>
            <param name="name">Header name</param>
            <param name="value">Value</param>
            <remarks>
                <para>Allows you to validate headers or modify the request when a specific header is set.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.StatusLine">
            <summary>
                Status line in a HTTP message divided into parts (array with three items).
            </summary>
            <remarks>
                <para>The content of the line depends on if this is a HTTP request </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.HttpVersion">
            <summary>
                Version of the HTTP protocol
            </summary>
            <remarks>
                <para>
                    Typically <c>HTTP/1.1</c> but can also be the old version <c>HTTP/1.0</c> or the new draft <c>HTTP/2.0</c>
                    (aka SPDY)
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.Body">
            <summary>
                Body in the HTTP message
            </summary>
            <remarks>
                <para>
                    The body has not been modified or parsed in any way. The actual stream is either a <c>MemoryStream</c> or
                    <c>FileStream</c> depending on the
                    size of the body.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.ContentLength">
            <summary>
                Length of the body in bytes.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.ContentType">
            <summary>
                Content type without encoding
            </summary>
            <remarks>
                <para>
                    To set encoding you have to use <c>httpMessage.Headers["content-type"] = "text/html; charset=utf8"</c> or
                    similar.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessage.ContentCharset">
            <summary>
                The encoding used in the document (if it's text of some sort)
            </summary>
            <remarks>
                <para>
                    To set encoding you have to use <c>httpMessage.Headers["content-type"] = "text/html; charset=utf8"</c> or
                    similar.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpRequest.CreateResponse">
            <summary>
            Create a response for this request.
            </summary>
            <returns>Response</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpRequest.HttpMethod">
            <summary>
                Method which was invoked.
            </summary>
            <remarks>
                <para>Typically <c>GET</c>, <c>POST</c>, <c>PUT</c>, <c>DELETE</c> or <c>HEAD</c>.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpRequest.Uri">
            <summary>
                Request UrI
            </summary>
            <remarks>
                <para>Is built using the <c>server</c> header and the path + query which is included in the request line</para>
                <para>If no <c>server</c> header is included "127.0.0.1" will be used as server.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpRequest.RemoteEndPoint">
            <summary>
            Address to the remote end point
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="httpMethod">Method like <c>POST</c>.</param>
            <param name="pathAndQuery">Absolute path and query string (if one exist)</param>
            <param name="httpVersion">HTTP version like <c>HTTP/1.1</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.CreateResponse">
            <summary>
            Create a response for this request.
            </summary>
            <returns>Response</returns>
            <remarks>
            <para>
            If you override this method you have to copy the PipelineIndexKey header like this:
            <code>
             var pipeline = Headers[PipelineIndexKey];
             if (pipeline != null)
             {
                response.Headers[PipelineIndexKey] = pipeline;
             }        
            </code>
            </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequestBase.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.HttpMethod">
            <summary>
                Method which was invoked.
            </summary>
            <remarks>
                <para>Typically <c>GET</c>, <c>POST</c>, <c>PUT</c>, <c>DELETE</c> or <c>HEAD</c>.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.Uri">
            <summary>
                Request UrI
            </summary>
            <remarks>
                <para>Is built using the <c>server</c> header and the path + query which is included in the request line</para>
                <para>If no <c>server</c> header is included "localhost" will be used as server.</para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.RemoteEndPoint">
            <summary>
            Address to the remote end point
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequestBase.StatusLine">
            <summary>
            Status line for requests is "HttpMethod PathAndQuery HttpVersion"
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequest.#ctor(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="httpMethod">Method like <c>POST</c>.</param>
            <param name="pathAndQuery">Absolute path and query string (if one exist)</param>
            <param name="httpVersion">HTTP version like <c>HTTP/1.1</c></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpRequest.CreateResponse">
            <summary>
            Create a response for this request.
            </summary>
            <returns>Response</returns>
            <remarks>
            <para>
            If you override this method you have to copy the PipelineIndexKey header like this:
            <code>
             var pipeline = Headers[PipelineIndexKey];
             if (pipeline != null)
             {
                response.Headers[PipelineIndexKey] = pipeline;
             }        
            </code>
            </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequest.Form">
            <summary>
            Submitted form items
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequest.Files">
            <summary>
            Submitted files
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpRequest.Cookies">
            <summary>
            Included cookies.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.Authenticate(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Authorize a request.
            </summary>
            <param name="request">Request being authenticated</param>
            <returns>Authenticated user if successful; otherwise null.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <value></value>
            <example>
            digest
            </example>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.BasicAuthentication.AuthenticationScheme">
            <summary>
            Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator">
            <summary>
            Implements Digest authentication.
            </summary>
            <remarks>Read RFC 2617 for more information</remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.DisableNonceCheck">
            <summary>
            Used by test classes to be able to use hardcoded values
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.#ctor(Griffin.Net.Protocols.Http.Authentication.IRealmRepository,Griffin.Net.Protocols.Http.Authentication.IAccountService)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator"/> class.
            </summary>
            <param name="realmRepository">Used to lookup the realm for a HTTP request</param>
            <param name="userService">Supplies users during authentication process.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.CreateChallenge(Griffin.Net.Protocols.Http.IHttpRequest,Griffin.Net.Protocols.Http.IHttpResponse)">
            <summary>
            Create a WWW-Authenticate header
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Encrypts parameters into a Digest string
            </summary>
            <param name="realm">Realm that the user want to log into.</param>
            <param name="userName">User logging in</param>
            <param name="password">Users password.</param>
            <param name="method">HTTP method.</param>
            <param name="uri">Uri/domain that generated the login prompt.</param>
            <param name="qop">Quality of Protection.</param>
            <param name="nonce">"Number used ONCE"</param>
            <param name="nc">Hexadecimal request counter.</param>
            <param name="cnonce">"Client Number used ONCE"</param>
            <returns>Digest encrypted string</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Encrypt(System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="ha1">Md5 hex encoded "userName:realm:password", without the quotes.</param>
            <param name="ha2">Md5 hex encoded "method:uri", without the quotes</param>
            <param name="qop">Quality of Protection</param>
            <param name="nonce">"Number used ONCE"</param>
            <param name="nc">Hexadecimal request counter.</param>
            <param name="cnonce">Client number used once</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.GetMd5HashBinHex(System.String)">
            <summary>
            Gets the Md5 hash bin hex2.
            </summary>
            <param name="toBeHashed">To be hashed.</param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.Scheme">
            <summary>
            Gets authenticator scheme
            </summary>
            <value></value>
            <example>
            digest
            </example>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.DigestAuthenticator.AuthenticationScheme">
            <summary>
            Gets name of the authentication scheme
            </summary>
            <remarks>"BASIC", "DIGEST" etc.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce">
            <summary>
            Used to keep track of a Digest authentication nonce
            </summary>
            <remarks>Only five attempts may be made.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.#ctor(System.DateTime)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce"/> class.
            </summary>
            <param name="expires">When nonce expires.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.Validate(System.Int32)">
            <summary>
            Check if the nonce can be used.
            </summary>
            <param name="value"></param>
            <returns>true if counter is currently unused and within the range; otherwise false;</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.PassedCounts">
            <summary>
            Gets all passed counts.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.LastUpdate">
            <summary>
            Gets time for last attempt.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.Digest.Nonce.Expired">
            <summary>
            Gets if nonce has expired.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService">
            <summary>
            Monitors all nonces.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.#ctor(System.TimeSpan)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService"/> class.
            </summary>
            <param name="expiresTimeout">How long a nonce is valid, default is 15 seconds.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.IsValid(System.String,System.Int32)">
            <summary>
            Checks if a nonce is valid
            </summary>
            <param name="value">nonce value</param>
            <param name="counter">nc counter</param>
            <returns>true if nonce is valid; otherwise false.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.CreateNonce">
            <summary>
            Create a new nonce
            </summary>
            <returns>Created nonce.</returns>
            <remarks>Valid Time span is configured in the <see cref="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.#ctor(System.TimeSpan)"/> constructor. Default time is 15 seconds.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.Digest.NonceService.Sweep(System.Object)">
            <summary>
            Remove expired nonces.
            </summary>
            <param name="state"></param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.HostAsRealmRepository">
            <summary>
            Uses <c>request.Uri.Host</c> as realm.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IRealmRepository">
            <summary>
            Returns the realm for a request.
            </summary>
            <remarks>Realms are used during authentication</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IRealmRepository.GetRealm(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Gets the realm for a request
            </summary>
            <param name="request">Request which realm we want to get</param>
            <returns>The realm that the request belongs to</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.HostAsRealmRepository.GetRealm(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Gets the realm for a request
            </summary>
            <param name="request">Request which realm we want to get</param>
            <returns>The realm that the request belongs to</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IAccountService">
            <summary>
            Provider returning user to be authenticated.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAccountService.Lookup(System.String,System.Uri)">
            <summary>
            Lookups the specified user
            </summary>
            <param name="userName">User name.</param>
            <param name="host">Typically web server domain name.</param>
            <returns>User if found; otherwise <c>null</c>.</returns>
            <remarks>
            User name can basically be anything. For instance name entered by user when using
            basic or digest authentication, or SID when using Windows authentication.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IAccountService.HashPassword(System.String,System.Uri,System.String)">
            <summary>
            Hash password to be able to do comparison
            </summary>
            <param name="userName"></param>
            <param name="host"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser">
            <remarks>The </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.Username">
            <summary>
            Gets or sets user name used during authentication.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.Password">
            <summary>
            Gets or sets unencrypted password.
            </summary>
            <remarks>
            Password as clear text. You could use <see cref="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.HA1"/> instead if your passwords
            are encrypted in the database.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IAuthenticationUser.HA1">
            <summary>
            Gets or sets HA1 hash.
            </summary>
            <remarks>
            <para>
            Digest authentication requires clear text passwords to work. If you
            do not have that, you can store a HA1 hash in your database (which is part of
            the Digest authentication process).
            </para>
            <para>
            A HA1 hash is simply a Md5 encoded string: "UserName:Realm:Password". The quotes should
            not be included. Realm is the currently requested Host (as in <c>Request.Headers["host"]</c>).
            </para>
            <para>
            Leave the string as <c>null</c> if you are not using HA1 hashes.
            </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IPrincipalFactory">
            <summary>
            Used to create <see cref="T:System.Security.Principal.IPrincipal"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.IPrincipalFactory.Create(Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext)">
            <summary>
            Create a new prinicpal
            </summary>
            <param name="context">Context used to identify the user.</param>
            <returns>Principal to use</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.IUserWithRoles">
            <summary>
            Used to be able to generate <see cref="T:System.Security.Principal.IPrincipal"/> directly.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.IUserWithRoles.RoleNames">
            <summary>
            Get a list of all roles
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext">
            <summary>
            Context for <see cref="T:Griffin.Net.Protocols.Http.Authentication.IPrincipalFactory"/>.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext.#ctor(Griffin.Net.Protocols.Http.IHttpRequest,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext"/> class.
            </summary>
            <param name="request">The request.</param>
            <param name="userName">user that have authenticated successfully.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext.UserName">
            <summary>
            Gets the name of the user which was provided by the <see cref="T:Griffin.Net.Protocols.Http.Authentication.IAccountService"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Authentication.PrincipalFactoryContext.Request">
            <summary>
            Gets the HTTP request.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository">
            <summary>
            Uses a single realm for all requests.
            </summary>
            <example>
            <code>
            var digestAuthenticator = new DigestAuthenticator(new SingleRealmRepository("DragonsDen"), _myUserService);
            </code>
            </example>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository"/> class.
            </summary>
            <param name="name">Name of the realm.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Authentication.SingleRealmRepository.GetRealm(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Gets the realm for a request
            </summary>
            <param name="request">Request which realm we want to get</param>
            <returns>The realm that the request belongs to</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpResponse">
            <summary>
            Complete HTTP resposne.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpResponseBase">
            <summary>
            A HTTP response with minimal parsing.
            </summary>
            <remarks>
            <para>The purpose of this class is to do as little as possible with the response to make the processing more straightforward and without
            any unnessacary steps.</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpResponse">
            <summary>
                A http response.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpResponse.StatusCode">
            <summary>
                HTTP status code. You typically choose one of <see cref="T:System.Net.HttpStatusCode"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpResponse.ReasonPhrase">
            <summary>
                Why the specified <see cref="P:Griffin.Net.Protocols.Http.IHttpResponse.StatusCode"/> was set.
            </summary>
            <remarks>
                <para>
                    The goal with the reason is to help the remote endpoint to understand why the specific code was chosen. i.e. it
                    allows you
                    to help the programmer to understand why a specific error code was set.
                </para>
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseBase.StatusCode">
            <summary>
                HTTP status code. You typically choose one of <see cref="T:System.Net.HttpStatusCode"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseBase.ReasonPhrase">
            <summary>
                Why the specified <see cref="P:Griffin.Net.Protocols.Http.HttpResponseBase.StatusCode"/> was set.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseBase.StatusLine">
            <summary>
            Status line for HTTP responses is "HttpVersion StatusCode ReasonPhrase"
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponse.Cookies">
            <summary>
            Cookies to send to the server side
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.BodyDecoders.UrlFormattedDecoder">
            <summary>
            Decodes URL encoded values.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.BodyDecoders.IBodyDecoder">
            <summary>
            Decodes body stream into the Form/Files properties.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BodyDecoders.IBodyDecoder.Decode(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Decode body stream
            </summary>
            <param name="message">Contains the body to decode.</param>
            <exception cref="T:Griffin.Net.Protocols.Http.BadRequestException">Body format is invalid for the specified content type.</exception>
            <returns><c>true</c> if the body was decoded; otherwise <c>false</c>.</returns>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.BodyDecoders.UrlFormattedDecoder.MimeType">
            <summary>
            The mimetype that this decoder is for.
            </summary>
            <value>application/x-www-form-urlencoded</value>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BodyDecoders.UrlFormattedDecoder.Decode(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Decode body stream
            </summary>
            <param name="message">Contains the body to decode.</param>
            <exception cref="T:System.FormatException">Body format is invalid for the specified content type.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.BodyDecoders.UrlFormattedDecoder.ContentTypes">
            <summary>
            All content types that the decoder can parse.
            </summary>
            <returns>A collection of all content types that the decoder can handle.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.BodyDecoders.CompositeBodyDecoder">
            <summary>
            Can provide one or more decoders.
            </summary>
            <remarks>The default implementation constructor uses <see cref="T:Griffin.Net.Protocols.Http.BodyDecoders.UrlFormattedDecoder"/> and <see cref="T:Griffin.Net.Protocols.Http.BodyDecoders.MultipartDecoder"/></remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BodyDecoders.CompositeBodyDecoder.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.BodyDecoders.CompositeBodyDecoder"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BodyDecoders.CompositeBodyDecoder.Decode(Griffin.Net.Protocols.Http.IHttpRequest)">
            <summary>
            Parses the specified message.
            </summary>
            <param name="message">The message.</param>
            <exception cref="T:System.FormatException">Body format is invalid for the specified content type.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.BodyDecoders.CompositeBodyDecoder.Add(System.String,Griffin.Net.Protocols.Http.BodyDecoders.IBodyDecoder)">
            <summary>
            Add another handlers.
            </summary>
            <param name="mimeType">Mime type</param>
            <param name="decoder">The decoder implementation. Must be thread safe.</param>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.BodyDecoders.Mono.HttpMultipart">
             <summary>
             Stream-based multipart handling.
            
             In this incarnation deals with an HttpInputStream as we are now using
             IntPtr-based streams instead of byte [].   In the future, we will also
             send uploads above a certain threshold into the disk (to implement
             limit-less HttpInputFiles). 
             </summary>
             <remarks>
             Taken from HttpRequest in mono (http://www.mono-project.com)
             </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.BodyDecoders.MultipartDecoder">
            <summary>
            Decodes multipart files.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.BodyDecoders.MultipartDecoder.FormData">
            <summary>
            form-data
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.BodyDecoders.MultipartDecoder.MimeType">
            <summary>
            multipart/form-data
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.BodyDecoders.MultipartDecoder.ContentTypes">
            <summary>
            All content types that the decoder can parse.
            </summary>
            <returns>A collection of all content types that the decoder can handle.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpException">
            <summary>
            A HTTP exception
            </summary>
            <remarks>HTTP exceptions will automatically generate a custom error page with the specified status code,
            opposed to all other exceptions which will generate a Internal Server Error.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpException.HttpStatusCode">
            <summary>
            Gets status code
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener
            </summary>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.ChannelTcpListener.LocalPort"/>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpListener.BodyDecoder">
            <summary>
            Used to decode the body of incoming request to form/files.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpMessageDecoder">
            <summary>
                Decodes HTTP messages
            </summary>
            <remarks>
                <para>
                    Per default the body is not decoded. To change that behavior you should assign a decoder to the
                    <see cref="P:Griffin.Net.Protocols.Http.HttpMessageDecoder.BodyDecoder"/> property.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.IMessageDecoder">
            <summary>
            
            </summary>
        </member>
        <member name="M:Griffin.Net.IMessageDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
            We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
            <remarks></remarks>
        </member>
        <member name="P:Griffin.Net.IMessageDecoder.MessageReceived">
            <summary>
            A message have been received.
            </summary>
            <remarks>
            Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessageDecoder.BodyDecoder">
            <summary>
                Used to parse body
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpMessageDecoder.MessageReceived">
            <summary>
                A message have been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpMessageEncoder">
            <summary>
                Used to encode request/response into a byte stream.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.IMessageEncoder">
            <summary>
                Message encoders are used to convert objects into binary form so that they can be transferred over a socket.
            </summary>
            <remarks>
                The format itself is determined by the protocol which is implemented. See all implementations.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessageEncoder.Prepare(System.Object)">
            <summary>
                Prepare the encoder so that the specified object can be encoded next.
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
            <remarks>
                The <c>buffer</c> variable is typically a wrapper around <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/>, but may be something
                else if required.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessageEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.Protocols.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.IMessageEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.Protocols.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpMessageEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.HttpResponseCookie">
            <summary>
            Response cookies also have an expiration and the path that they are valid for.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IResponseCookie">
            <summary>
            Response cookies have to specify where and when they are valid.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IResponseCookie.Domain">
            <summary>
            Gets domain that the cookie is valid under
            </summary>
            <remarks><c>null</c> means not specified</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IResponseCookie.ExpiresUtc">
            <summary>
            Gets when the cookie expires.
            </summary>
            <remarks><see cref="F:System.DateTime.MinValue"/> means that the cookie expires when the session do so.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IResponseCookie.Path">
            <summary>
            Gets path that the cookie is valid under.
            </summary>
            <remarks><c>null</c> means not specified</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponseCookie.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.HttpResponseCookie"/> class.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.HttpResponseCookie.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseCookie.Domain">
            <summary>
            Gets domain that the cookie is valid under
            </summary>
            <remarks><c>null</c> means not specified</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseCookie.ExpiresUtc">
            <summary>
            Gets when the cookie expires.
            </summary>
            <remarks><see cref="F:System.DateTime.MinValue"/> means that the cookie expires when the session do so.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.HttpResponseCookie.Path">
            <summary>
            Gets path that the cookie is valid under.
            </summary>
            <remarks><c>null</c> means not specified.</remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpFile">
            <summary>
            A file included in a HTTP request.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFile.Move(System.String)">
            <summary>
            Move the file
            </summary>
            <param name="destination">Destination (path and file name)</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFile.Delete">
            <summary>
            Delete file
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.ContentType">
            <summary>
            Gets or sets content type.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.Name">
            <summary>
            Gets or sets name in form.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.OriginalFileName">
            <summary>
            Gets or sets name original file name
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFile.TempFileName">
            <summary>
            Gets or sets filename for locally stored file.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IHttpFileCollection">
            <summary>
            Collection of files
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFileCollection.Contains(System.String)">
            <summary>
            Checks if a file exists.
            </summary>
            <param name="name">Name of the file (form item name)</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFileCollection.Add(Griffin.Net.Protocols.Http.IHttpFile)">
            <summary>
            Add a new file.
            </summary>
            <param name="file">File to add.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IHttpFileCollection.Clear">
            <summary>
            Remove all files from disk.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFileCollection.Item(System.String)">
            <summary>
            Get a file
            </summary>
            <param name="name">Name in the HTTP form.</param>
            <returns>File if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IHttpFileCollection.Count">
            <summary>
            Gets number of files
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IParameter">
            <summary>
            Parameter in <see cref="T:Griffin.Net.Protocols.Http.IParameterCollection"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameter.Add(System.String)">
            <summary>
            Add a new parameter value
            </summary>
            <param name="value">Value to add</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Value">
            <summary>
            Gets *last* value.
            </summary>
            <remarks>
            Parameters can have multiple values. This property will always get the last value in the list.
            </remarks>
            <value>String if any value exist; otherwise <c>null</c>.</value>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Name">
            <summary>
            Gets or sets name.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Item(System.Int32)">
            <summary>
            Get one of the values.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameter.Count">
            <summary>
            Get number of values
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.IParameterCollection">
            <summary>
            Collection of parameters
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameterCollection.Get(System.String)">
            <summary>
            Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameterCollection.Add(System.String,System.String)">
            <summary>
            Add a query string parameter.
            </summary>
            <param name="name">Parameter name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.IParameterCollection.Exists(System.String)">
            <summary>
            Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameterCollection.Count">
            <summary>
            Gets number of parameters.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.IParameterCollection.Item(System.String)">
            <summary>
            Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpCookieParser">
            <summary>
            Parses a request cookie header value.
            </summary>
            <remarks>This class is not thread safe.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpCookieParser.Parse(System.String)">
            <summary>
            Parse cookie string
            </summary>
            <returns>A generated cookie collection.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpFile">
            <summary>
            A HTTP file in a request.
            </summary>
            <remarks>The temporary file will be deleted when the request/response ends.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFile.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFile.Move(System.String)">
            <summary>
            Move the file
            </summary>
            <param name="destination">Destination (path and file name)</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFile.Delete">
            <summary>
            Delete file
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.Name">
            <summary>
            Gets or sets form element name
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.OriginalFileName">
            <summary>
            Gets or sets client side file name
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.ContentType">
            <summary>
            Gets or sets mime content type
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFile.TempFileName">
            <summary>
            Gets or sets full path to local file
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpFileCollection">
            <summary>
            Collection of files in a HTTP request.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Contains(System.String)">
            <summary>
            Checks if a file exists.
            </summary>
            <param name="name">Name of the file (form item name)</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Add(Griffin.Net.Protocols.Http.IHttpFile)">
            <summary>
            Add a new file.
            </summary>
            <param name="file">File to add.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Clear">
            <summary>
            Remove all files from disk.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Item(System.String)">
            <summary>
            Get a file
            </summary>
            <param name="name">Name in form</param>
            <returns>File if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HttpFileCollection.Count">
            <summary>
            Gets number of files
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue">
            <summary>
                Value for a http header
            </summary>
            <remarks>
                <para>
                    Created to take care of optional value parameters.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HttpHeaderValue.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.ParameterCollection">
            <summary>
                Collection of parameters in a HTTP header.
            </summary>
            <remarks>
                <para>
                    Most of the HTTP headers can have parameters in the header value. typically they are stored as
                    <code>TheHeaderValue;and=some,parameters=true</code>
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Parse(System.String)">
            <summary>
            Parse string
            </summary>
            <param name="value">contains "a=b,c=d" etc</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Parse(System.String,Griffin.Net.Protocols.Http.Messages.ParameterCollection)">
            <summary>
            Parse string
            </summary>
            <param name="value">contains "a=b,c=d" etc</param>
            <param name="target">Collection to fill with the values</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Add(System.String,System.String)">
            <summary>
                Add a query string parameter.
            </summary>
            <param name="name">Parameter name</param>
            <param name="value">Value</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Exists(System.String)">
            <summary>
                Checks if the specified parameter exists
            </summary>
            <param name="name">Parameter name.</param>
            <returns><c>true</c> if found; otherwise <c>false</c>;</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Get(System.String)">
            <summary>
                Get a parameter.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Clear">
            <summary>
                Remove all item
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ParameterCollection.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Count">
            <summary>
                Gets number of parameters.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ParameterCollection.Item(System.String)">
            <summary>
                Gets last value of an parameter.
            </summary>
            <param name="name">Parameter name</param>
            <returns>String if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HeaderCollection">
            <summary>
                Collection of HTTP headers
            </summary>
            <remarks>The values are not encoded, you must encode them when serializing the message.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderCollection"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.#ctor(System.Action{System.String,System.String})">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderCollection"/> class.
            </summary>
            <param name="headerSetCallback">Callback invoked every time a new header is set.</param>
            <exception cref="T:System.ArgumentNullException">headerSetCallback</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Add(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as the value of header entry. Subsequent values are only used to maintain a history of state changes of the header and MAY be ignored. This implementation will IGNORE all subsequent headers</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Count">
            <summary>
            Number of headers
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.HeaderCollection.Item(System.String)">
            <summary>
            Used to fetch headers
            </summary>
            <param name="name">Lower case name</param>
            <returns>header if found; otherwise <c>null</c>.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.HeaderParser">
            <summary>
                Used to parse the HTTP header.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.HeaderParser"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.Parse(Griffin.Net.Channels.ISocketBuffer,System.Int32)">
            <summary>
                Will try to parse everything in the buffer
            </summary>
            <param name="buffer">Buffer to read from.</param>
            <param name="offset">Where to start parsing in the buffer.</param>
            <returns>offset where the parser ended.</returns>
            <remarks>
                <para>
                    Do note that the parser is for the header only. The <see cref="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.Completed"/> event will
                    indicate that there might be body bytes left in the buffer. You have to handle them by yourself.
                </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.Completed">
            <summary>
            The header part of the request/response has been parsed successfully. The remaining bytes is for the body
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.HeaderParsed">
            <summary>
            We've parsed a header and it's value.
            </summary>
        </member>
        <member name="F:Griffin.Net.Protocols.Http.Messages.HeaderParser.RequestLineParsed">
            <summary>
            We've parsed a request line, meaning that all headers is for a HTTP Request.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.HeaderParser.Reset">
            <summary>
            Reset parser state
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.Parameter">
            <summary>
                A parameter in a HTTP header field.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.GetEnumerator">
            <summary>
                Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
                A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.Add(System.String)">
            <summary>
                Add a new parameter value
            </summary>
            <param name="value">Value to add</param>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
                An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.Parameter.ToString">
            <summary>
                Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
                A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Values">
            <summary>
                Gets a list of all values.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Value">
            <summary>
                Gets *last* value.
            </summary>
            <remarks>
                Parameters can have multiple values. This property will always get the last value in the list.
            </remarks>
            <value>String if any value exist; otherwise <c>null</c>.</value>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Name">
            <summary>
                Gets or sets name.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Item(System.Int32)">
            <summary>
                Get one of the values.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.Parameter.Count">
            <summary>
                Get number of values
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.ReaderResult">
            <summary>
            Result from <see cref="M:Griffin.Net.Protocols.Http.Messages.TextReaderExtensions.ReadToEnd(System.IO.TextReader,System.String)"/>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.ReaderResult.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Http.Messages.ReaderResult"/> class.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ReaderResult.Value">
            <summary>
            Value read
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Http.Messages.ReaderResult.Delimiter">
            <summary>
            Found delimiter
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.TextReaderExtensions">
            <summary>
            Extensions for the standard text reader
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.TextReaderExtensions.ReadToEnd(System.IO.TextReader,System.String)">
            <summary>
            </summary>
            <param name="reader"></param>
            <param name="delimiters"></param>
            <returns></returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.Messages.UrlDecoder">
            <summary>
            Parses query string
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.UrlDecoder.Parse(System.IO.TextReader,Griffin.Net.Protocols.Http.IParameterCollection)">
            <summary>
            Parse a query string
            </summary>
            <param name="reader">string to parse</param>
            <param name="parameters">Parameter collection to fill</param>
            <returns>A collection</returns>
            <exception cref="T:System.ArgumentNullException"><c>reader</c> is <c>null</c>.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.Messages.UrlDecoder.Parse(System.String)">
            <summary>
            Parse a query string
            </summary>
            <param name="queryString">string to parse</param>
            <returns>A collection</returns>
            <exception cref="T:System.ArgumentNullException"><c>queryString</c> is <c>null</c>.</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Http.PipelinedMessageQueue">
            <summary>
                A priority message queue which uses <c>ConcurrentPriorityQueue</c> from Microsoft
                (http://blogs.msdn.com/b/pfxteam/archive/2010/04/04/9990342.aspx)
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.PipelinedMessageQueue.Enqueue(System.Object)">
            <summary>
                Enqueue a message
            </summary>
            <param name="message">message to enqueue</param>
            <remarks>
                <para>
                    Messages do not have to be placed in order, place them as they should be sent out.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Http.PipelinedMessageQueue.TryDequeue(System.Object@)">
            <summary>
                Get the next message that should be sent
            </summary>
            <param name="msg">Message to send</param>
            <returns><c>true</c> if there was a message to send.</returns>
        </member>
        <member name="T:Griffin.Net.Channels.ITcpChannelFactory">
            <summary>
            Used to create channels.
            </summary>
            <remarks>
            <para>Can be used to adjust how all lower level functions should work, like protecting everything with SSL</para>
            <para></para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.ITcpChannelFactory.Create(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.Protocols.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
            Create a new channel
            </summary>
            <param name="readBuffer">Buffer which should be used when reading from the socket</param>
            <param name="encoder">Used to encode outgoing data</param>
            <param name="decoder">Used to decode incoming data</param>
            <returns>Created channel</returns>
        </member>
        <member name="P:Griffin.Net.Channels.ITcpChannelFactory.OutboundMessageQueueFactory">
            <summary>
            create a new queue which are used to store outbound messages in the created channel.
            </summary>
            <returns>Factory method</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.IMessageSerializer">
            <summary>
            Serialize or deserialize the object which is transferred.
            </summary>
            <remarks>
            <para>A suggestions is that you use the <c>Type.AssemblyQualifiedName</c> as the content name of your application is .NET only.</para>
            <para>The methods must be isolated (i.e. should be able to call the same instance them from several threads).</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.IMessageSerializer.Serialize(System.Object,System.IO.Stream,System.String@)">
            <summary>
            Serialize an object to the stream.
            </summary>
            <param name="source"></param>
            <param name="destination"></param>
            <param name="contentType"></param>
            <returns>Content name (will be passed to the <see cref="M:Griffin.Net.Protocols.MicroMsg.IMessageSerializer.Deserialize(System.String,System.IO.Stream)"/> method in the other end)</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.IMessageSerializer.Deserialize(System.String,System.IO.Stream)">
            <summary>
            Deserialize the content from the stream.
            </summary>
            <param name="contentType">Used to identify the object which is about to be deserialized. Specified by the <c>Serialize()</c> method when invoked in the other end point.</param>
            <param name="source">Stream that contains the object to deserialize.</param>
            <returns>Created object</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">Deserialization failed</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageClient">
            <summary>
                A client implementation for transferring objects over the MicroMessage protocol
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder">
            <summary>
            Decode messages encoded with <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/>.
            </summary>
            <remarks>
            <para>As <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/> can out-of-the-box send <c>Stream</c>-drived classes and <c>byte[]</c> arrays this class
            has to handle that too.
            </para>
            <para>
            Streams will always be either <c>MemoryStream</c> or <c>FileStream</c> depending of the content-length. Same things goes for messages
            which are sent as <c>byte[]</c> arrays. They will also be received as streams.
            </para>
            </remarks>
        </member>
        <member name="F:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.FixedHeaderLength">
            <summary>
            Size of the fixed header: (version, content length, type name length)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.MicroMsg.MicroMessageDecoder.MessageReceived">
            <summary>
            A new message have been received.
            </summary>
            <remarks>
            <para>The message will be a deserialized message or a <c>Stream</c> derived object (if the sender sent a <c>Stream</c> or a <c>byte[]</c> array).</para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder">
            <summary>
                Takes any object that the serializer supports and transfers it over the wire.
            </summary>
            <remarks>
            The encoder also natively supports <c>byte[]</c> arrays and <c>Stream</c> derived objects (as long as the stream have a size specified). These objects
            will be transferred without invoking the serializer.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.#ctor(Griffin.Net.Protocols.MicroMsg.IMessageSerializer)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/> class.
            </summary>
            <param name="serializer">Serialiser used to serialize the messages that should be sent. You might want to pick a serializer which is reasonable fast.</param>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.#ctor(Griffin.Net.Protocols.MicroMsg.IMessageSerializer,Griffin.Net.Buffers.IBufferSlice)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder"/> class.
            </summary>
            <param name="serializer">Serialiser used to serialize the messages that should be sent. You might want to pick a serializer which is reasonable fast.</param>
            <param name="bufferSlice">Used when sending information.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">bufferSlice; At least the header should fit in the buffer, and the header can be up to 520 bytes in the current version.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.Protocols.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks>
                <c>true</c> if the message have been sent successfully; otherwise <c>false</c>.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.MicroMessageEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.NamespaceDoc">
            <summary>
                MicroMessage is a small message format with a binary header.
            </summary>
            <remarks>
            <para>
            The header was designed to be backwards compatible and support newer versions. The contents of the body is unspecified and up to the peers to decide.
            </para>
                The header contains the following fields:
                <list type="table">
                    <item>
                        <term>Headerlength</term>
                        <description><c>short</c>, number of bytes that are for the header. First byte is directly after this field. <para>This field was added
            to be able to include new features without affecting previous versions</para></description>
                    </item>
                    <item>
                        <term>Version</term>
                        <description><c>byte</c>, Defines the version of the micro protocol. Current version is 1.</description>
                    </item>
                    <item>
                        <term>ContentLength</term>
                        <description><c>int</c>, Defines the length of the body. The body starts directly after the header.</description>
                    </item>
                    <item>
                        <term>Typelength</term>
                        <description><c>sbyte</c>, Defines the length of the next header value.</description>
                    </item>
                    <item>
                        <term>TypeName</term>
                        <description>
                            Fully qualified assembly name of the type that is our payload.
                            <para>
                                The default encoding of the name is UTF8. You may use another encoding (to support foreign characters in the type names), but then it's important that you communicate out the encoding.
                            </para>
                        </description>
                    </item>
                </list>
                <para>
                    To work with computers that use different byte ordering, all integer values that are sent over the network are sent in network byte order which has the most significant byte first.
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.MicroMsg.Serializers.DataContractMessageSerializer">
            <summary>
            Uses the DataContract XML serializer.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.Server.MicroMessageTcpListener.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.MicroMsg.Server.MicroMessageTcpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="T:Griffin.Net.Protocols.ProtocolTcpListener">
            <summary>
                Listens on one of the specified protocols
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.#ctor(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.Start(System.Net.IPAddress,System.Int32)">
            <summary>
                Start this listener
            </summary>
            <param name="address">Address to accept connections on</param>
            <param name="port">Port to use. Set to <c>0</c> to let the OS decide which port to use. </param>
            <seealso cref="P:Griffin.Net.Protocols.ProtocolTcpListener.LocalPort"/>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.Stop">
            <summary>
            Stop the listener.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.Configure(Griffin.Net.ChannelTcpListenerConfiguration)">
            <summary>
                To allow the sub classes to configure this class in their constructors.
            </summary>
            <param name="configuration"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.OnClientConnected(Griffin.Net.Channels.ITcpChannel)">
            <summary>
                A client have connected (nothing have been sent or received yet)
            </summary>
            <param name="channel">Channel which we created for the remote socket.</param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.OnClientDisconnected(Griffin.Net.Channels.ITcpChannel,System.Exception)">
            <summary>
                A client have disconnected
            </summary>
            <param name="channel">Channel representing the client that disconnected</param>
            <param name="exception">
                Exception which was used to detect disconnect (<c>SocketException</c> with status
                <c>Success</c> is created for graceful disconnects)
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.ProtocolTcpListener.OnMessage(Griffin.Net.Channels.ITcpChannel,System.Object)">
            <summary>
                Receive a new message from the specified client
            </summary>
            <param name="source">Channel for the client</param>
            <param name="msg">Message (as decoded by the specified <see cref="T:Griffin.Net.IMessageDecoder"/>).</param>
        </member>
        <member name="P:Griffin.Net.Protocols.ProtocolTcpListener.ChannelFactory">
            <summary>
                Used to create channels. Default is <see cref="T:Griffin.Net.Channels.TcpChannelFactory"/>.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ProtocolTcpListener.MessageReceived">
            <summary>
                Delegate invoked when a new message is received
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ProtocolTcpListener.MessageSent">
            <summary>
                Delegate invoked when a message have been sent to the remote end point
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.ProtocolTcpListener.LocalPort">
            <summary>
                Port that the server is listening on.
            </summary>
            <remarks>
                You can use port <c>0</c> in <see cref="M:Griffin.Net.Protocols.ProtocolTcpListener.Start(System.Net.IPAddress,System.Int32)"/> to let the OS assign a port. This method will then give you the
                assigned port.
            </remarks>
        </member>
        <member name="E:Griffin.Net.Protocols.ProtocolTcpListener.ClientConnected">
            <summary>
                A client have connected (nothing have been sent or received yet)
            </summary>
        </member>
        <member name="E:Griffin.Net.Protocols.ProtocolTcpListener.ClientDisconnected">
            <summary>
                A client have disconnected
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.IsFramePending(System.String)">
            <summary>
            Check if we are waiting on a ACK/NACK for the specified frame.
            </summary>
            <param name="messageId">Message id</param>
            <returns><c>true</c> if we are waiting on an ack/nack; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.GetSubscription(System.String)">
            <summary>
            Find our subscription
            </summary>
            <param name="messageId">A message which should have been distributed using a MESSAGE frame</param>
            <returns>Subscription</returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">Failed to find a subscription where the message '{0}' is pending (waiting for an ack/nack). Is the subscription really set to use 'client' or 'client-individual' acks?</exception>
            <exception cref="T:System.ArgumentNullException">messageId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.EnqueueInTransaction(System.String,System.Action,System.Action)">
            <summary>
            Enqueue work in an existing transaction (i.e. you must have invoked <c>BeginTransaction()</c> first)
            </summary>
            <param name="transactionId">Transaction identifier</param>
            <param name="commitAction">Action that will be invoked when the transaction is committed.</param>
            <param name="rollbackAction"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)">
            <summary>
            Begin a new transaction
            </summary>
            <param name="transactionId">Identifier. Must be unique within the same client connection</param>
            <exception cref="T:System.InvalidOperationException">Transaction has already been started.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.CommitTransaction(System.String)">
            <summary>
            Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.RollbackTransaction(System.String)">
            <summary>
            Rollback a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.SubscriptionExists(System.String)">
            <summary>
            Checks if a subscription have been created (typically using the "SUBSCRIBE" frame).
            </summary>
            <param name="subscriptionId">Subscription identifier (arbitrary string as specified by the client)</param>
            <returns><c>true</c> if the subscription exists; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.AddSubscription(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Add a new subscription
            </summary>
            <param name="subscription">Subscription that the client requested</param>
            <remarks>
            The client can have one or more active subscriptions in the same connection. And all subscriptions may have their own AckType. 
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.RemoveSubscription(System.String)">
            <summary>
            Remove a subscription (if it exists)
            </summary>
            <param name="subscriptionId">Identifier as specified when the subscription was created using a "SUBSCRIBE" frame.</param>
            <returns>Remove the subscription</returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.SetAsAuthenticated(System.String)">
            <summary>
            We have successfully authenticated this client.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.Send(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Send a frame to the client.
            </summary>
            <param name="frame">A server side frame</param>
            <exception cref="T:System.InvalidOperationException">If one attempted to send a client frame.</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompClient.HasActiveTransactions">
            <summary>
            Determines if there are one or more active transactions.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompClient.SessionKey">
            <summary>
            Identifier which was created during the authentication process.
            </summary>
            <remarks>Authentication is always required, no matter if a user/pass is supplied or not.</remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.IStompClient.RemoteEndpoint">
            <summary>
            Address from where the client is connected.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.IStompQueue.Enqueue(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Put a message in our queue. 
            </summary>
            <param name="message"></param>
            <remarks>
            Messages within transactions will be put on hold until the transaction is commited.
            
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager">
            <summary>
            Transaction manager.
            </summary>
            <remarks>
            All transaction ids must only be unique within the scope of a client connection.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Begin(System.String)">
            <summary>
            Begin a new transaction
            </summary>
            <param name="transactionId">Identifier. Must be unique within the same client connection</param>
            <exception cref="T:System.InvalidOperationException">Transaction has already been started.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Enqueue(System.String,System.Action,System.Action)">
            <summary>
            Enqueue work in an existing transaction (i.e. you must have invoked <c>BeginTransaction()</c> first)
            </summary>
            <param name="transactionId">Transaction identifier</param>
            <param name="commitTask">Action that will be invoked when the transaction is committed.</param>
            <param name="rollbackTask"></param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Rollback(System.String)">
            <summary>
            Rollback a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Begin(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Commit(System.String)">
            <summary>
            Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Begin(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.Cleanup">
            <summary>
            Remove all existing transactions (rollback all)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.ITransactionManager.HasActiveTransactions">
            <summary>
            Determines if there are one or more active transactions.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.AbortHandler">
            <summary>
            Rollback transaction
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.BeginHandler">
            <summary>
            Begin a new transaction
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.CommitHandler">
            <summary>
            Commit transaction
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.ConnectHandler.CheckCredentials(Griffin.Net.Protocols.Stomp.Broker.IStompClient,Griffin.Net.Protocols.Stomp.IFrame,Griffin.Net.Protocols.Stomp.IFrame@)">
            <summary>
            
            </summary>
            <param name="client"></param>
            <param name="request"></param>
            <param name="errorFrame"></param>
            <returns><c>true</c> means that we should exist.</returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.DisconnectHandler">
            <summary>
            Client want to disconect.
            </summary>
            <remarks>
            Package is sent to make sure that all packages before this one have been processed.
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.MessageHandlers.SendHandler">
            <summary>
            Takes care of messages that a client want to send to a queue.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository.Get(System.String)">
            <summary>
            Fetch a queue
            </summary>
            <param name="queueName"></param>
            <returns>Queue</returns>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">Queue was not found</exception>
            <exception cref="T:System.ArgumentNullException">queueName</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.MemoryQueueRepository.Add(Griffin.Net.Protocols.Stomp.Broker.StompQueue)">
            <summary>
            Adds a queue to the repository.
            </summary>
            <param name="queue">The queue.</param>
            <exception cref="T:System.ArgumentNullException">queue</exception>
            <exception cref="T:System.ArgumentException">Queue must have a name;queue.Name</exception>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.Services.NoAuthenticationService">
            <summary>
            Simply says that authentication is not activated (i.e. should be skipped)
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.Cleanup">
            <summary>
                Remove all existing transactions (rollback all)
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Services.TransactionManager.HasActiveTransactions">
            <summary>
                Determines if
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompBroker.#ctor(Griffin.Net.Protocols.Stomp.Broker.Services.IQueueRepository)">
            <summary>
            </summary>
            <param name="repository">
                Used to provide all queues that this broker is for. There is a built in class,
                <see cref="T:Griffin.Net.Protocols.Stomp.Broker.Services.MemoryQueueRepository"/>, which you can use.
            </param>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompBroker.ServerName">
            <summary>
            Name of the server.
            </summary>
            <value>
            Should be in the format "ServerName/versionNumber". 
            </value>
            <example>
            Griffin Queue/1.0
            </example>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompBroker.LocalPort">
            <summary>
            Port that the server is listening on.
            </summary>
            <remarks>
            You can use port <c>0</c> in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.StompBroker.Start(System.Net.IPAddress,System.Int32)"/> to let the OS assign a port. This method will then give you the assigned port.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.#ctor(Griffin.Net.Channels.ITcpChannel,Griffin.Net.Protocols.Stomp.Broker.ITransactionManager)">
            <summary>
            </summary>
            <param name="channel"></param>
            <param name="transactionManager">
                Must be unique for this client. i.e. the transaction ids used in this client is not
                globally unique
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.AddSubscription(Griffin.Net.Protocols.Stomp.Broker.Subscription)">
            <summary>
            Add a new subscription
            </summary>
            <param name="subscription">Subscription that the client requested</param>
            <exception cref="T:System.ArgumentNullException">subscription</exception>
            <remarks>
            The client can have one or more active subscriptions in the same connection. And all subscriptions may have their own AckType.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.RemoveSubscription(System.String)">
            <summary>
            Removes the subscription.
            </summary>
            <param name="id">The id.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">id</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.SetAsAuthenticated(System.String)">
            <summary>
                We have successfully authenticated this client.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.BeginTransaction(System.String)">
            <summary>
            Begins the transaction.
            </summary>
            <param name="transactionId">The transaction id.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.RollbackTransaction(System.String)">
            <summary>
            Rollbacks the transaction.
            </summary>
            <param name="transactionId">The transaction id.</param>
            <exception cref="T:System.ArgumentNullException">transactionId</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.CommitTransaction(System.String)">
            <summary>
            Commit a transaction
            </summary>
            <param name="transactionId">Transaction identifier that was specified in <see cref="M:Griffin.Net.Protocols.Stomp.Broker.IStompClient.BeginTransaction(System.String)"/>.</param>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">No transaction have been started with that identifier.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.Send(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Send a frame to the client.
            </summary>
            <param name="frame">A server side frame</param>
            <exception cref="T:System.ArgumentNullException">frame</exception>
            <exception cref="T:System.InvalidOperationException">If one attempted to send a client frame.</exception>
            <remarks>
            Messages sent directly through the client are not being modified in any way. If you want to get ack, receipts etc, send through a subscription instead.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.IsFramePending(System.String)">
            <summary>
            Determines
            </summary>
            <param name="messageId"></param>
            <returns></returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompClient.GetSubscription(System.String)">
            <summary>
            find the subscription where the specified message is pending (i.e. waiting to be acked/nacked).
            </summary>
            <param name="messageId">The message id.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">messageId</exception>
            <exception cref="T:Griffin.Net.Protocols.Stomp.Broker.NotFoundException">Failed to find a subscription where the message '{0}' is pending (waiting for an ack/nack). Is the subscription really set to use 'client' or 'client-individual' acks?</exception>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.IsAuthenticated">
            <summary>
            Gets if this client has got the CONNECT/STOMP header and got authenticated.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.Channel">
            <summary>
            Channel used for communication
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.SessionKey">
            <summary>
            Identifier for this specific connection
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.RemoteEndpoint">
            <summary>
                Address from where the client is connected.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.StompClient.HasActiveTransactions">
            <summary>
            Returns if this client has one or more active transactions
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Broker.StompQueue">
            <summary>
            
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Requeue(System.Collections.Generic.IEnumerable{Griffin.Net.Protocols.Stomp.IFrame})">
            <summary>
            Will put all frames first in the queue again
            </summary>
            <param name="frame"></param>
            <remarks>
            Should only be used for queues that got one client and where the message ordering is important.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.StompQueue.Enqueue(Griffin.Net.Protocols.Stomp.IFrame)">
            <summary>
            Put a message in our queue. 
            </summary>
            <param name="message"></param>
            <remarks>
            Messages within transactions will be put on hold until the transaction is commited.
            
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Broker.Subscription.#ctor(Griffin.Net.Protocols.Stomp.Broker.IStompClient,System.String)">
            <summary>
            
            </summary>
            <param name="client">Client that the subscription belongs to</param>
            <param name="id">Arbitary string as specified by the client.</param>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.Id">
            <summary>
            Arbitary string as specified by the client.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.QueueName">
            <summary>
            Name of the queue.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.AckType">
            <summary>
            How each message should be acknowledged by the subscribing client
            </summary>
            <remarks>
            <c>client</c> = accumulative acknowledgment (i.e. all messages up to the specified one is ACK:ed). <c>client-individual</c>, each specific message must be acked. <c>auto</c> = All messages are
            considered ACK:ed as soon as they are sent.
            </remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Broker.Subscription.MaxMessagesPerSecond">
            <summary>
            Amount of messages which can be sent to a client per second.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.IFrame.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as the value of header entry. Subsequent values are only used to maintain a history of state changes of the header and MAY be ignored. This implementation will IGNORE all subsequent headers</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.BasicFrame.AddHeader(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>
                    If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as
                    the value of header entry. Subsequent values are only used to maintain a history of state changes of the header
                    and MAY be ignored. This implementation will IGNORE all subsequent headers
                </para>
            </remarks>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection">
            <summary>
                Collection of STOMP headers
            </summary>
            <remarks>The values are not encoded, you must encode them when serializing the message.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.Add(System.String,System.String)">
            <summary>
                Adds the specified name.
            </summary>
            <param name="name">The name.</param>
            <param name="value">The value.</param>
            <exception cref="T:System.ArgumentNullException">name</exception>
            <exception cref="T:System.FormatException">
                Header name may not contain colon, CR or LF.
                or
                Header value may not contain colon, CR or LF.
            </exception>
            <remarks>
                <para>If a client or a server receives repeated frame header entries, only the first header entry SHOULD be used as the value of header entry. Subsequent values are only used to maintain a history of state changes of the header and MAY be ignored. This implementation will IGNORE all subsequent headers</para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.Frames.HeaderParser">
            <summary>
                Used to parse the STOMP header.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.#ctor">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.Frames.HeaderParser"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Parse(Griffin.Net.Channels.ISocketBuffer,System.Int32)">
            <summary>
                Will try to parse everything in the buffer
            </summary>
            <param name="buffer">Buffer to read from.</param>
            <remarks>offset where the parser ended.</remarks>
            <remarks>
                <para>
                    Do note that the parser is for the header only. The <see cref="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Completed"/> event will
                    indicate that there might be body bytes left in the buffer. You have to handle them by yourself.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Reset">
            <summary>
                Reset parser state
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.Completed">
            <summary>
                The header part of the request/response has been parsed successfully. The remaining bytes is for the body
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.HeaderParsed">
            <summary>
                We've parsed a header and it's value.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.HeaderParser.FrameNameParsed">
            <summary>
                The frame method has been parsed.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.Server.StompError.ReceiptId">
            <summary>
                If the errenous frame included a receipt header, the ERROR frame SHOULD set the receipt-id header to match the value of the receipt header of the frame which the error is related to.
            </summary>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.Frames.Server.StompError.Message">
            <summary>
                Short description of what went wrong.
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.StompClientLight">
            <summary>
            Used to talk with a STOMP server.
            </summary>
            <remarks>
            This client can only parse STOMP frames, it doesn't know what they mean.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
            <remarks></remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Stomp.StompDecoder.MessageReceived">
            <summary>
                A message have been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.Prepare(System.Object)">
            <summary>
                Are about to send a new message
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.Protocols.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Protocols.Stomp.StompTcpListener">
            <summary>
            Listens on STOMP messages from a client.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Stomp.StompTcpListener.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Griffin.Net.Protocols.Stomp.StompTcpListener"/> class.
            </summary>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringDecoder.ProcessReadBytes(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                We've received bytes from the socket. Build a message out of them.
            </summary>
            <param name="buffer">Buffer</param>
            <remarks></remarks>
        </member>
        <member name="P:Griffin.Net.Protocols.Strings.StringDecoder.MessageReceived">
            <summary>
                A message have been received.
            </summary>
            <remarks>
                Do note that streams are being reused by the decoder, so don't try to close it.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.Prepare(System.Object)">
            <summary>
                Prepare the encoder so that the specified object can be encoded next.
            </summary>
            <param name="message">Message to send</param>
            <remarks>
                Can be used to prepare the next message. for instance serialize it etc.
            </remarks>
            <exception cref="T:System.NotSupportedException">Message is of a type that the encoder cannot handle.</exception>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.Send(Griffin.Net.Channels.ISocketBuffer)">
            <summary>
                Buffer structure used for socket send operations.
            </summary>
            <param name="buffer">
                Do note that there are not buffer attached to the structure, you have to assign one yourself using
                <see cref="M:Griffin.Net.Channels.ISocketBuffer.SetBuffer(System.Int32,System.Int32)"/>. This choice was made
                to prevent unnecessary copy operations.
            </param>
            <remarks>
                The <c>buffer</c> variable is typically a wrapper around <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/>, but may be something
                else if required.
            </remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.OnSendCompleted(System.Int32)">
            <summary>
                The previous <see cref="M:Griffin.Net.Protocols.IMessageEncoder.Send(Griffin.Net.Channels.ISocketBuffer)"/> has just completed.
            </summary>
            <param name="bytesTransferred"></param>
            <remarks><c>true</c> if the message have been sent successfully; otherwise <c>false</c>.</remarks>
        </member>
        <member name="M:Griffin.Net.Protocols.Strings.StringEncoder.Clear">
            <summary>
                Remove everything used for the last message
            </summary>
        </member>
        <member name="T:Griffin.Net.Channels.TcpChannelFactory">
            <summary>
                Creates a <see cref="T:Griffin.Net.Channels.TcpChannel"/>.
            </summary>
            <remarks>
                <para>
                    Allows you to provide your own custom channels to be able to control the IO operations that this library uses.
                </para>
            </remarks>
        </member>
        <member name="M:Griffin.Net.Channels.TcpChannelFactory.Create(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.Protocols.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
                Create a new channel
            </summary>
            <param name="readBuffer">Buffer which should be used when reading from the socket</param>
            <param name="encoder">Used to encode outgoing data</param>
            <param name="decoder">Used to decode incoming data</param>
            <returns>Created channel</returns>
        </member>
        <member name="P:Griffin.Net.Channels.TcpChannelFactory.OutboundMessageQueueFactory">
            <summary>
                create a new queue which are used to store outbound messages in the created channel.
            </summary>
            <returns>Factory method</returns>
        </member>
        <member name="T:Griffin.Net.Channels.SecureTcpChannelFactory">
            <summary>
            Used to create secure channels for our library.
            </summary>
        </member>
        <member name="M:Griffin.Net.Channels.SecureTcpChannelFactory.Create(Griffin.Net.Buffers.IBufferSlice,Griffin.Net.Protocols.IMessageEncoder,Griffin.Net.IMessageDecoder)">
            <summary>
            Create a new channel
            </summary>
            <param name="readBuffer">Buffer which should be used when reading from the socket</param>
            <param name="encoder">Used to encode outgoing data</param>
            <param name="decoder">Used to decode incoming data</param>
            <returns>Created channel</returns>
        </member>
        <member name="P:Griffin.Net.Channels.SecureTcpChannelFactory.OutboundMessageQueueFactory">
            <summary>
            create a new queue which are used to store outbound messages in the created channel.
            </summary>
            <returns>Factory method</returns>
        </member>
        <member name="M:Griffin.ObjectExtensions.ToDictionary(System.Object)">
            <summary>
                Turn anonymous object to dictionary
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:Griffin.QueueFullException">
            <summary>
                Queue is full and no more items may be enqueued.
            </summary>
        </member>
        <member name="M:Griffin.QueueFullException.#ctor(System.String)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.QueueFullException"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
        </member>
        <member name="M:Griffin.QueueFullException.#ctor(System.String,System.Exception)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.QueueFullException"/> class.
            </summary>
            <param name="queueName">Name of the queue.</param>
            <param name="inner">The inner.</param>
        </member>
        <member name="M:Griffin.QueueFullException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
                Initializes a new instance of the <see cref="T:Griffin.QueueFullException"/> class.
            </summary>
            <param name="info">
                The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object
                data about the exception being thrown.
            </param>
            <param name="context">
                The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual
                information about the source or destination.
            </param>
        </member>
        <member name="M:Griffin.QueueFullException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
            <PermissionSet>
              <IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Read="*AllFiles*" PathDiscovery="*AllFiles*" />
              <IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="SerializationFormatter" />
              </PermissionSet>
        </member>
        <member name="P:Griffin.QueueFullException.QueueName">
            <summary>
                Name of the queue that is full.
            </summary>
        </member>
        <member name="T:Griffin.TypeExtensions">
            <summary>
            Extension methods for <c>Type</c>.
            </summary>
        </member>
        <member name="M:Griffin.TypeExtensions.IsAssignableFromGeneric(System.Type,System.Type)">
            <summary>
            Check if generic types matches
            </summary>
            <param name="serviceType">Service/interface</param>
            <param name="concreteType">Concrete/class</param>
            <returns><c>true</c> if the concrete implements the service; otherwise <c>false</c></returns>
        </member>
        <member name="M:Griffin.TypeExtensions.IsSimpleType(System.Type)">
            <summary>
            Checks if the specified type is a type which should not be traversed when building an object hiararchy.
            </summary>
            <param name="type">Type to check</param>
            <returns><c>true</c> if it's a simple type; otherwise <c>false</c>.</returns>
            <example>
            <code>
            public string Build(object instance)
            {
                var sb = new StringBuilder();
                Build(instance, "", sb);
                return sb.ToString();
            }
            
            protected void Build(object instance, string prefix, StringBuilder result)
            {
                foreach (var propInfo in instance.GetType().GetProperties())
                {
                    if (instance.GetType().IsSimpleType())
                    {
                        var value = propInfo.GetValue(instance, null);
                        result.AppendLine(prefix + propInfo.Name + ": " + value);
                    }
                    else
                    {
                        var newPrefix = prefix == "" ? propInfo.Name : prefix + ".";
                        Build(newPrefix, 
            }
            
            while (!type.IsSimpleType())
            {
            }
            
            </code>
            </example>
        </member>
    </members>
</doc>
